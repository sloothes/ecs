<!DOCTYPE html>
<html lang="en">
	<head>

		<title>Legacy ECS Engine (pre-alpha 0.12)</title>

		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">
		<link rel="stylesheet" href="/css/jcrop.css">

		<script src="/js/watch.js"></script>
		<script src="/js/Objectid.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>
		<script src="/js/jcrop.js"></script>

		<style>

			body {
				margin: 0px;
				font-size: 13px;
				font-family: sans-serif;
				background-repeat: repeat;
				background-image: url("https://i.imgur.com/rnZZU0i.png") !important;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-matcap,
			.btn-terrain {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}

			.btn-matcap + .btn-matcap,
			.btn-terrain + .btn-terrain {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/ecs/js/three.js"></script>
		<script src="/ecs/js/TabUI.js"></script>
		<script src="/ecs/js/MeshWalk.js"></script>
		<script src="/ecs/js/UVsDebug.js"></script>
		<script src="/ecs/js/FBXLoader.js"></script>
		<script src="/ecs/js/VirtualInput.js"></script>
		<script src="/ecs/js/KeyboardState.js"></script>
		<script src="/ecs/js/EditorControls.js"></script>
		<script src="/ecs/js/SubdivisionModifier.js"></script>
		<script src="/ecs/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

		<script src="/ecs/engine/Enviroment.js"></script>
		<script src="/ecs/engine/core/localPlayer.js"></script>
		<script src="/ecs/engine/core/cameraControls.js"></script>
		<script src="/ecs/engine/core/keyboardState.js"></script>
	<!-- script src="/ecs/engine/core/keyInputControls.js"></script -->

		<script>

			debugMode = true;
			const Signal = signals.Signal;

		//	Global helpers.

			Number.prototype.format = function (){
				return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
			};

		//	save_file.js
			function saveString( text, filename ) {
				save( new Blob( [ text ], { type: "text/plain" } ), filename );
			}

			function saveArrayBuffer( buffer, filename ) {
				save( new Blob( [ buffer ], { type: "application/octet-stream" } ), filename );
			}

			function save( blob, filename ) {

				var link = document.createElement( "a" );
				link.href = URL.createObjectURL( blob );
				link.download = filename || "untitled";
				link.click();

			}

		//	round.js
			function round(number, precision) {
				var shift = function (number, precision, reverseShift) {
					if (reverseShift) {
						precision = -precision;
					}  
					numArray = ("" + number).split("e");
					return +(numArray[0] + "e" + (numArray[1] ? (+numArray[1] + precision) : precision));
				};
				return shift(Math.round(shift(number, precision, false)), precision, true);
			}

		//	array_move.js
			function array_move( arr, old_index, new_index ){

				if (new_index >= arr.length) {
					var k = new_index - arr.length + 1;
					while (k--) {
						arr.push(undefined);
					}
				}

				arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
			}

		//	deep_copy.js
			function deepCopy(obj) {
				if (Object.prototype.toString.call(obj) === "[object Array]") {
					var out = [], i = 0, len = obj.length;
					for ( ; i < len; i++ ) {
						out[i] = arguments.callee(obj[i]);
					}
				//	console.log("out:", out);
					return out;
				}
				if (typeof obj === "object") {
					var out = {}, i;
					for ( i in obj ) {
						out[i] = arguments.callee(obj[i]);
					}
				//	console.log("out:", out);
					return out;
				}
				return obj;
			}

			function copyObject(obj) {

			//	1. copy has same prototype as orig
				var copy = Object.create(Object.getPrototypeOf(obj));

			//	2. copy has all of origâ€™s properties
				copyOwnPropertiesFrom(copy, obj);

				return copy; // warning: shallow copy!

			//	The properties are copied from orig to copy via this function:

				function copyOwnPropertiesFrom(target, source) {
					Object.getOwnPropertyNames(source).forEach(function(propKey) {
						var desc = Object.getOwnPropertyDescriptor(source, propKey);
						Object.defineProperty(target, propKey, desc);
					});
					return target;
				};

			}

			function quaternionFromNormal( normal, quaternion ){

				return setDirection(normal, quaternion);

				function setDirection(normal, quaternion) {
					quaternion = quaternion || new THREE.Quaternion();
				//	vector is assumed to be normalized.
					if (normal.y > 0.99999) {
						quaternion.set(0, 0, 0, 1);
					} else if (normal.y < -0.99999) {
						quaternion.set(1, 0, 0, 0);
					} else {
						var axis = new THREE.Vector3();
						axis.set(normal.z, 0, -normal.x).normalize();
						var radians = Math.acos(normal.y);
						quaternion.setFromAxisAngle(axis, radians);
					}

					return quaternion;
				}
			}

		//	Helpers.

			function takeCameraControls( target, offset ){
				cameraControls.trackObject = target;
				cameraControls.offset.y = offset || 0;
			}

		</script>

		<script>

		//	TabUI.

			(function(){

				var sidePanel = createSidePanel();
				document.body.appendChild( sidePanel );

				var loginTab = TabUI.add( "Login", "login-tab" );
				var debugTab = TabUI.add( "Debug", "debug-tab" );
				var levelTab = TabUI.add( "Levels", "level-tab" );
				var editorTab = TabUI.add( "Editor", "editor-tab" );
				var cameraTab = TabUI.add( "Camera", "camera-tab" );
				var controlTab = TabUI.add( "Controls", "control-tab" );
				var playersTab = TabUI.add( "Players", "players-tab" );
				var materialTab = TabUI.add( "Materials", "material-tab" );
				var animationTab = TabUI.add( "Animations", "animation-tab" );

				TabUI.append("Editor", "Controls", "Camera", "Players", "Animations", "Materials", "Levels", "Debug" );
				TabUI.Editor.role.classList.add("active");
				TabUI.Editor.tab.classList.add("in","active");

			})();

		</script>

		<script>

			debugMode && (function(){
				var geometry = new THREE.BoxGeometry();
				var material = new THREE.MeshLambertMaterial();
				var cube = new THREE.Mesh(geometry, material);
				localPlayer.add( cube );
			})();

			const keyboard = new KeyboardState();

			const keyInputControls = (function( characterController, cameraController ){

				const rad = Math.PI/2;
				const deg = Math.PI/180;
				const clock = new THREE.Clock();
				const keyCodes = keyboard.keyCodes;
				const keyInputController = new MW.KeyInputControl();

			//	var JUMP     = keyCodes[32]; // "space".
			//	var UP       = keyCodes[33] || keyCodes[69]; // "page UP"     or "E"
			//	var DOWN     = keyCodes[34] || keyCodes[81]; // "page DOWN"   or "Q"
			//	var LEFT     = keyCodes[37] || keyCodes[68]; // "arrow LEFT"  or "D"
			//	var RIGHT    = keyCodes[39] || keyCodes[65]; // "arrow RIGHT" or "A"
			//	var FORWARD  = keyCodes[38] || keyCodes[87]; // "arrow UP"    or "W"
			//	var BACKWARD = keyCodes[40] || keyCodes[83]; // "arrow DOWN"  or "S"

				characterController.movementSpeed = 5; // debug!

				function resetMovementSpeedDirection(){
					var movementSpeed = Math.abs( characterController.movementSpeed );
					characterController.movementSpeed = movementSpeed;
					debugMode && console.log( "reset:", characterController.movementSpeed );
				}

				function updateMovementSpeedDirection(FORWARD, BACKWARD){
					var movementSpeed = Math.abs( characterController.movementSpeed );
					if ( !FORWARD && BACKWARD ) 
						characterController.movementSpeed = -movementSpeed;
					else characterController.movementSpeed = movementSpeed;
				}

				//	debugMode && console.log( 
				//		"update move:", FORWARD, BACKWARD, 
				//		characterController.movementSpeed 
				//	);

				function updateControllerDirection( dt ){
					var left  = keyCodes[37] || keyCodes[68]; // "arrow LEFT"  or "D"
					var right = keyCodes[39] || keyCodes[65]; // "arrow RIGHT" or "A"
					if ( left && !right ) 
						characterController.direction -= dt*rad; // step;
					else if ( right && !left ) 
						characterController.direction += dt*rad; // step;
				}

				function syncWithCameraController() {
					var cameraFrontAngle = cameraController.getFrontAngle();
					var characterFrontAngle = keyInputController.frontAngle;
					characterController.direction = (4 * rad) - cameraFrontAngle + characterFrontAngle;
				}

				keyInputController.addEventListener( "movekeyon", function() { 
					var forwards = keyCodes[38] || keyCodes[87]; // "arrow UP"    or "W"
					var backward = keyCodes[40] || keyCodes[83]; // "arrow DOWN"  or "S"
					updateMovementSpeedDirection( forwards, backward );
					if ( forwards || backward ) characterController.isRunning = true;
				});

				keyInputController.addEventListener( "movekeyoff", function() { 
					resetMovementSpeedDirection();
					characterController.isRunning = false; 
				});

				keyInputController.addEventListener( "jumpkeypress", function() { 
					characterController.jump(); 
				});

				keyInputController.addEventListener( "movekeychange", function(){
				//	syncWithCameraController();
					var forwards = keyCodes[38] || keyCodes[87]; // "arrow UP"    or "W"
					var backward = keyCodes[40] || keyCodes[83]; // "arrow DOWN"  or "S"
					updateMovementSpeedDirection( forwards, backward );
					(function(){
						if ( forwards || backward ) 
							characterController.isRunning = true; 
						else if ( !forwards && !backward )
							characterController.isRunning = false; 
					})();
				});

				(function update(){

					requestFrameID = requestAnimationFrame( update );
					if (  keyInputController.isDisabled ) return;
				//	if ( !keyInputController.isMoveKeyHolded ) return;

					var dt = clock.getDelta();
					updateControllerDirection( dt );

				})();

				return keyInputController;

			})( localPlayer.controller, cameraControls );

		</script>

		<script>

/*
			const keyboard = new KeyboardState();

		//	Direction state.
			var UP = keyboard.pressed("E") || keyboard.pressed("pageup");
			var DOWN = keyboard.pressed("Q") || keyboard.pressed("pagedown");
			var LEFT = keyboard.pressed("A") || keyboard.pressed("left");
			var RIGHT = keyboard.pressed("D") || keyboard.pressed("right");
			var FORWARD = keyboard.pressed("W") || keyboard.pressed("up");
			var BACKWARD = keyboard.pressed("S") || keyboard.pressed("down");

			function resetState(){
				UP = false;
				DOWN = false;
				LEFT = false;
				RIGHT = false;
				FORWARD = false;
				BACKWARD = false;
			}

			function updateState(){
				UP = keyboard.pressed("E") || keyboard.pressed("pageup");
				DOWN = keyboard.pressed("Q") || keyboard.pressed("pagedown");
				LEFT = keyboard.pressed("A") || keyboard.pressed("left");
				RIGHT = keyboard.pressed("D") || keyboard.pressed("right");
				FORWARD = keyboard.pressed("W") || keyboard.pressed("up");
				BACKWARD = keyboard.pressed("S") || keyboard.pressed("down");
			}

			function updateDirectionState(){
				resetState(); // important.
				LEFT = keyInputControls.isLeft;
				RIGHT = keyInputControls.isRight;
				FORWARD = keyInputControls.isUp;
				BACKWARD = keyInputControls.isDown;
			}

			function reverseMovementSpeed(){
				localPlayer.controller.movementSpeed = -localPlayer.controller.movementSpeed;
			}

				function updateState(){
				//	debugMode && console.log(e);

					if ( keyInputController.isDisabled ) return;
					if (!keyInputController.isMoveKeyHolded ) return;

					resetState(); // important.

					if ( keyboard.pressed("E") || keyboard.pressed("pageup") )   UP = true;
					if ( keyboard.pressed("Q") || keyboard.pressed("pagedown") ) DOWN = true;
					if ( keyboard.pressed("A") || keyboard.pressed("left") )     LEFT = true;
					if ( keyboard.pressed("D") || keyboard.pressed("right") )    RIGHT = true;
					if ( keyboard.pressed("W") || keyboard.pressed("up") )       FORWARD = true;
					if ( keyboard.pressed("S") || keyboard.pressed("down") )     BACKWARD = true;

				//	debugMode && console.log( UP, DOWN, LEFT, RIGHT, FORWARD, BACKWARD );
				}
				window.addEventListener( "keydown", function(e){
				//	update state direction.
					updateDirectionState(e); // important!
				//	update movement direction.
					var movementSpeed = characterController.movementSpeed;
					if ( FORWARD  && movementSpeed < 0 ) reverseMovementSpeed();
					if ( BACKWARD && movementSpeed > 0 ) reverseMovementSpeed();
				});

				window.addEventListener( "keyup", function(e){

				//	if ( keyInputController.isDisabled ) return;
				//	if (!keyInputController.isMoveKeyHolded ) return;

					updateState(); // important!

				//	update state direction.

				//	reset movement direction/speed.
					characterController.movementSpeed = Math.abs( characterController.movementSpeed );
				});

				(function update(){

					requestFrameID = requestAnimationFrame( update );
					var dt = clock.getDelta(); // important! outside of udate.

					if (  keyInputController.isDisabled ) return;
					if ( !keyInputController.isMoveKeyHolded ) return;

					if ( LEFT  ) characterController.direction -= dt*rad; // step;
					if ( RIGHT ) characterController.direction += dt*rad; // step;

				})();
*/


		</script>

		<script>

		//	joystickControls.

			const joystickControls = (function(cameraController, characterController){

				var joysticControls1 = document.createElement( "div" );
				joysticControls1.id = "joystick-controls-1";
				joysticControls1.classList.add("joystick-controls");
				document.body.appendChild( joysticControls1 );

				var joysticControls2 = document.createElement( "div" );
				joysticControls2.id = "joystick-controls-2";
				joysticControls2.classList.add("joystick-controls");
				document.body.appendChild( joysticControls2 );

				var joystick1Selector  = "#joystick1";
				var joystick2Selector  = "#joystick2";
				var jumpButtonSelector = "#jumpButton";

				var joystickControlsSelector  = ".joystick-controls";
				var joystickControls1Selector = "#joystick-controls-1";
				var joystickControls2Selector = "#joystick-controls-2";

				var cameraJoystick = new virtualInput.Joystick( $( joystickControls1Selector ), 94, { id: "joystick1" } );
				var playerJoystick = new virtualInput.Joystick( $( joystickControls2Selector ), 94, { id: "joystick2" } );
				var jumpButton     = new virtualInput.Button(   $( joystickControls1Selector ), 58, { id: "jumpButton", label: "<b>JUMP</b>" } ); // buttonSvgSrc

				playerJoystick.addEventListener( "active", function onActive() { 

					if (  characterController.isJumping 
					  || !characterController.isGrounded 
					  ||  characterController.isOnSlope ) {
						return;
					}

					characterController.isRunning = true;

				});

				playerJoystick.addEventListener( "disactive", function onDisactive() { 

					if (  characterController.isJumping 
					  || !characterController.isGrounded 
					  ||  characterController.isOnSlope ) {
						return;
					}

					characterController.isRunning = false;

				});

				jumpButton.addEventListener( "press", function onPress() { 

					if (  characterController.isJumping 
					  || !characterController.isGrounded 
					  ||  characterController.isOnSlope ) {
						return;
					}

					characterController.jump();

				});

			//	updates.

				const rad = Math.PI/2;

				playerJoystick.update = function(){

					if ( this.isActive ) {

						characterController.direction = (3 * rad) - cameraController.getFrontAngle() + this.angle;

					}
				};

				cameraJoystick.update = function(){

					if ( this.isActive ) {

						cameraController.setLatLon(
							cameraController.lat + this.position.y * 0.5, // deg.
							cameraController.lon - this.position.x        // deg.
						);

					}
				};

				(function update(){
					cameraJoystick.update();
					playerJoystick.update();
					requestFrameID = requestAnimationFrame( update );
				})();


				return playerJoystick;

			})( cameraControls, localPlayer.controller );

		</script>

	</body>
</html>
