<!DOCTYPE html>
<html lang="en">
	<head>

		<title>Legacy ECS Engine (pre-alpha 0.20)</title>

		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">
		<link rel="stylesheet" href="/css/jcrop.css">

		<script src="/js/watch.js"></script>
		<script src="/js/Objectid.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>
		<script src="/js/jcrop.js"></script>

		<style>

			body {
				margin: 0px;
				font-size: 13px;
				font-family: sans-serif;
				background-repeat: repeat;
				background-image: url("https://i.imgur.com/rnZZU0i.png") !important;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-matcap,
			.btn-terrain {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}

			.btn-matcap + .btn-matcap,
			.btn-terrain + .btn-terrain {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/ecs/js/three.js"></script>
		<script src="/ecs/js/TabUI.js"></script>
		<script src="/ecs/js/MeshWalk.js"></script>
		<script src="/ecs/js/UVsDebug.js"></script>
		<script src="/ecs/js/FBXLoader.js"></script>
		<script src="/ecs/js/VirtualInput.js"></script>
		<script src="/ecs/js/KeyboardState.js"></script>
		<script src="/ecs/js/EditorControls.js"></script>
		<script src="/ecs/js/camera-controls.js"></script>
		<script src="/ecs/js/SubdivisionModifier.js"></script>
		<script src="/ecs/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

		<script>

			debugMode = true;
			const Signal = signals.Signal;

		//	TabUI.

			(function(){

				var sidePanel = createSidePanel();
				document.body.appendChild( sidePanel );

			})();

		</script>

		<script src="/ecs/engine/core/enviroment.js"></script>
		<script src="/ecs/engine/core/entity.js"></script>
		<script src="/ecs/engine/core/helpers.js"></script>
		<script src="/ecs/engine/core/localPlayer.js"></script>
		<script src="/ecs/engine/core/cameraControls.js"></script>
		<script src="/ecs/engine/core/keyboardState.js"></script>
		<script src="/ecs/engine/core/keyInputControls.js"></script>
		<script src="/ecs/engine/core/joystickControls.js"></script>
		<script src="/ecs/engine/core/keyboard.js"></script>
		<script src="/ecs/engine/editor/EditorTab.js"></script>
		<script src="/ecs/engine/editor/MaterialTab.js"></script>

		<script>

		//	MaterialEditor.js

		//	Create a Material to hold editor values.

			const materialEditor = (function(){

			//	UndoArray Class (extends Array class).

				function UndoArray(){
					var array = new Array(0);
					Object.setPrototypeOf( array, UndoArray.prototype );
					return array; // important!
				}

				UndoArray.prototype = Object.create(Array.prototype); // important!
				UndoArray.prototype.clear = function(){ this.length = 0; };
				UndoArray.prototype.move = array_move.bind(UndoArray.prototype); // TO BE TESTED!!!

				const undo = new UndoArray(); debugMode && console.log( {"undo": undo} );
				const redo = new UndoArray(); debugMode && console.log( {"redo": redo} );

				const RAD2DEG = THREE.Math.RAD2DEG;
				const DEG2RAD = THREE.Math.DEG2RAD;

			//	droplists.

				const key_droplist = document.getElementById("material-keys-droplist");
				const type_droplist = document.getElementById("material-type-droplist");
				const color_droplist = document.getElementById("material-color-droplist");
				const vector_droplist = document.getElementById("material-vector-droplist");
				const entity_droplist = document.getElementById("material-entities-droplist");
				const texture_droplist = document.getElementById("material-map-droplist");

			//	mouse inputs.

				const increase_v = document.getElementById("material-value-increase");
				const decrease_v = document.getElementById("material-value-decrease");
				const increase_x = document.getElementById("material-vector-x-increase");
				const increase_y = document.getElementById("material-vector-y-increase");
				const decrease_x = document.getElementById("material-vector-x-decrease");
				const decrease_y = document.getElementById("material-vector-y-decrease");

				const increase_r = document.getElementById("material-color-r-increase");
				const increase_g = document.getElementById("material-color-g-increase");
				const increase_b = document.getElementById("material-color-b-increase");
				const decrease_r = document.getElementById("material-color-r-decrease");
				const decrease_g = document.getElementById("material-color-g-decrease");
				const decrease_b = document.getElementById("material-color-b-decrease");

			//	keyboard inputs.

				const color_r = document.getElementById("material-color-r-input");
				const color_g = document.getElementById("material-color-g-input");
				const color_b = document.getElementById("material-color-b-input");
				const vector_x = document.getElementById("material-vector-x-input");
				const vector_y = document.getElementById("material-vector-y-input");
				const text_input  = document.getElementById("material-text-input");
				const value_input = document.getElementById("material-value-input");

			//	material tab buttons.

				const exit_button = document.getElementById("material-exit-mode");
				const redo_button = document.getElementById("material-redo-button");
				const undo_button = document.getElementById("material-undo-button");
				const clone_button = document.getElementById("clone-material-button");
				const create_button = document.getElementById("create-material-button");
				const remove_button = document.getElementById("remove-material-button");
				const needsUpdate_button = document.getElementById("material-needs-update");

			//	MaterialEditor class (extends THREE.MeshStandardMaterial Class).
			//	A THREE.Material that holds editor values. Extends THREE.Material.

				const editor = (function(){

					var interval;

					function MaterialEditor(){
						var material = new THREE.Material();
						Object.setPrototypeOf( material, MaterialEditor.prototype );
						return material; // important!
					}

					MaterialEditor.prototype = Object.create(THREE.Material.prototype); // important!

					MaterialEditor.prototype.copy = function( source ){ 
						THREE[ source.type ].prototype.copy.call( this, source ); // important!
						return this;
					};

					MaterialEditor.prototype.reset = function(){ 

						var source = new THREE.MeshStandardMaterial();

						var keys = "";
						keys += "color,emissive,specular,normalScale,displacementScale,";
						keys += "name,type,uuid,side,opacity,alphaTest,transparent,premultipliedAlpha,";
						keys += "fog,lights,visible,overdraw,dithering,precision,colorWrite,flatShading,vertexColors,";
						keys += "blending,blendSrc,blendDst,blendEquation,blendSrcAlpha,blendDstAlpha,blendEquationAlpha,";
						keys += "depthFunc,depthTest,depthWrite,shadowSide,clipShadows,clipIntersection,";
						keys += "polygonOffset,polygonOffsetUnits,polygonOffsetFactor,";
						keys += "map,aoMap,envMap,bumpMap,alphaMap,lightMap,normalMap,specularMap,";
						keys += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap,";
						keys += "metalness,roughness,bumpScale,reflectivity,";
						keys += "refractionRatio,displacementBias,normalMapType,";
						keys += "aoMapIntensity,envMapIntensity,emissiveIntensity,lightMapIntensity,";
						keys += "wireframe,wireframeLinecap,wireframeLinejoin,wireframeLinewidth,";
						keys += "skinning,morphTargets,morphNormals,combine,shininess,";
						keys += "depthPacking,scale,gapSize,linecap,linejoin,linewidth,";
						keys += "dashSize,size,rotation,sizeAttenuation";

						keys.split(",").forEach(function( key ){
							switch ( key ){

								case "name":
									editor.name = "editor";
								break;

								case "color":
									if ( editor[ key ] === undefined )
										editor[ key ] = new THREE.Color(1,1,1);
									else
										editor[ key ].setRGB(1,1,1);
								break;

								case "emissive":
								case "specular":
									if ( editor[ key ] === undefined )
										editor[ key ] = new THREE.Color(0,0,0);
									else
										editor[ key ].setRGB(0,0,0);
								break;

								case "normalScale":
									if ( editor[ key ] === undefined )
										editor[ key ] = new THREE.Vector2(1,1);
									else
										editor[ key ].set(1,1);
								break;

								default:
									editor[ key ] = source[ key ];
								break;

								case "clippingPlanes": {

									var srcPlanes = source.clippingPlanes,
										dstPlanes = null;

									if ( srcPlanes !== null ) {

										var n = srcPlanes.length;
										dstPlanes = new Array( n );

										for ( var i = 0; i !== n; ++ i )
											dstPlanes[ i ] = srcPlanes[ i ].clone();

									}

									editor.clippingPlanes = dstPlanes;

								} break;

								case "userData":
									editor.userData = JSON.parse( JSON.stringify( source.userData ) );
								break;

							}
						});

					//	debugMode && console.log("reset:", {"editor": editor});

						return this;
					};

					MaterialEditor.prototype.fromJSON = function( json ){
					//	param: a texture json {object}

						var editor = this;

						var loader = new THREE.MaterialLoader();
						var material = loader.parse( json );
						debugMode && console.log( material );

						editor.reset(); // important!

						editor.copy( material );
						editor.type = material.type;
						editor.uuid = material.uuid;

					};

					MaterialEditor.prototype.undo = function(){

						var editor = this;

						if ( !undo.length ) return;

					//	Get undo json.
						var json = undo.shift();

						if ( !json ) return;

					//	Move json to redo.
						redo.unshift( json );

						clearTimeout( interval );
						interval = setTimeout( function(){

						//	Copy material state (undo).
							editor.fromJSON( json ); // update.

							debugMode && console.log( "undo:", undo.length, "redo:", redo.length );

						}, 250);

					};

					MaterialEditor.prototype.redo = function(){

						var editor = this;

						if ( !redo.length ) return;

					//	Get redo json.
						var json = redo.shift();

						if ( !json ) return;

					//	Move json to undo.
						undo.unshift( json );

						clearTimeout( interval );
						interval = setTimeout( function(){

						//	Copy texture state (redo).
							editor.fromJSON( json ); // update.

							debugMode && console.log( "undo:", undo.length, "redo:", redo.length );

						}, 250);
					};

					MaterialEditor.prototype.update = function( value ){

					//	Copies the values of the target material of material
					//	entity manager. Does not updates the target material.
					//	dependences: material_entities {material manager},
					//	param: a material id {string or number},

						var editor = this;

						editor.reset(); // important!

					//	get target material.
						var material = material_entities.getMaterialById( value );
					//	debugMode && console.log( "editor material:", material );

						if ( !material ) {
							editor.reset();
							console.log("editor update:", false);
							return false; // important!
						}

					//	copy material (update).
						editor.copy( material );
						editor.type = material.type;
						editor.uuid = material.uuid;

					//	return true.
						console.log("editor update:", true);
						return true; // important!

					};

					return new MaterialEditor();

				})();

			//	editor.reset(); // important!

			//	helpers.

				function getObjectByEntityId( value ){

					var entities_droplist = document.getElementById("entities-droplist"); // important!

					if ( arguments.length ) 
						var id = parseInt( value );
					else
						var id = parseInt( entities_droplist.value );

					if ( id === NaN ) return;

					return scene.getObjectById( id );
				}

				function getMaterialByEntityId( value ){

					var material_droplist = document.getElementById("material-entities-droplist"); // important!

					if ( arguments.length ) 
						var id = parseInt( value );
					else
						var id = parseInt( material_droplist.value );

					if ( id === NaN ) return;

					return material_entities.find( function( material ){
						return material.id === id;
					});
				}

			//	add to undo/redo.
			//	You want addtoUndo to keyinput change event and to mouse
			//	clickend event.
			//	Should you place addtoUndo on each keyinput change event?
			//	Should you place addtoUndo on each mouse clickend event?
			// 	Watch editor value and if is differend add an undo json?

				function addtoUndo(){
					var json = editor.toJSON();
					json && undo.unshift( json );
					return;
				}

				function clearUndoRedo(){
					undo.clear();
					redo.clear();
					return;
				}

				function resetUIValues(){
					color_r.value = "";
					color_g.value = "";
					color_b.value = "";
					vector_x.value = "";
					vector_y.value = "";
					text_input.value = "";
					value_input.value = "";
					key_droplist.value = "";
					color_droplist.value = "";
					vector_droplist.value = "";
					entity_droplist.value = "";
					texture_droplist.value = "";
					return;
				}

			//	exit from edit mode.

				function exitFromEditMode(){
					editor.reset();
					resetUIValues();
					clearUndoRedo();
					return;
				}

			//	Undo/Redo/Exit buttons.

				(function(){

					var interval;

					exit_button.addEventListener( "click", function(){
						clearTimeout( interval ); 
						interval = setTimeout( exitFromEditMode, 250);
					});

					undo_button.addEventListener( "click", function(){
						debugMode && console.log("undo:",undo.length,"redo:",redo.length);
						if ( !entity_droplist.value ) clearUndoRedo();
						else undo.length && editor.undo(); // undo.
					});

					redo_button.addEventListener( "click", function(){
						debugMode && console.log("undo:",undo.length,"redo:",redo.length);
						if ( !entity_droplist.value ) clearUndoRedo();
						else redo.length && editor.redo(); // redo.
					});

				})();

			//	Tab droplists.

				(function(){

					key_droplist.addEventListener( "change", key_droplist.blur );
					color_droplist.addEventListener( "change", color_droplist.blur );
					vector_droplist.addEventListener( "change", vector_droplist.blur );
					entity_droplist.addEventListener( "change", entity_droplist.blur );
					texture_droplist.addEventListener( "change", texture_droplist.blur );

					document.getElementById("entities-droplist").addEventListener( "change", function(){

						var object = scene.getObjectById( Number(this.value) );

						if ( object && object.material ) {

							if ( !Array.isArray(object.material) ) 
								callWatchers( entity_droplist, "onchange", "change", 
								entity_droplist.value = String(object.material.id) );
							if ( Array.isArray(object.material) && object.material.length ) 
								callWatchers( entity_droplist, "onchange", "change", 
								entity_droplist.value = String(object.material[0].id) );

						}  else exitFromEditMode();

						// else callWatchers( entity_droplist, "onchange", "change", entity_droplist.value = "" );

					});


					watch( key_droplist, "onchange", function( property, event, key ){

						if ( !key || editor[key] == undefined ) 
							return [ value_input.value, text_input.value ] = ["",""];

						if ( key && editor[key] !== undefined && typeof editor[key] === "string" ) {

							debugMode && console.log( typeof editor[key]  ); // debug!

							[text_input.value, value_input.value] = [ editor[key], "" ];

						} else if ( key && editor[key] !== undefined && typeof editor[key] === "number" ) {
							
							debugMode && console.log( typeof editor[key]  ); // debug!

							if ( ("displacementScale,polygonOffsetUnits,polygonOffsetFactor,opacity,"
							+ "alphaTest,reflectivity,refractionRatio,bumpScale,metalness,roughness,displacementBias,"
							+ "aoMapIntensity,envMapIntensity,emissiveIntensity,lightMapIntensity,wireframeLinewidth,"
							+ "linewidth,size,scale,gapSize,dashSize,shininess").split(",").includes(key) ) {

								debugMode && console.log( "number (1):", typeof editor[key]  ); // debug!

								[value_input.value, text_input.value] = [ editor[key].toFixed(2), "" ];

							} else if ( key === "rotation" ) {

								[value_input.value, text_input.value] = [ (RAD2DEG*editor[key]).toFixed(1), "" ];

							} else [value_input.value, text_input.value] = [ editor[key].toFixed(0), "" ];

						} else if ( key && editor[key] !== undefined && typeof editor[key] === "boolean" ) {

							debugMode && console.log( typeof editor[key]  ); // debug!

							[text_input.value, value_input.value] = [ "", editor[key] ];

						} else [ value_input.value, text_input.value ] = ["",""];

					});

					watch( vector_droplist, "onchange", function( property, event, key ){

						if ( key && editor[key] !== undefined && editor[key].isVector2 ) 

							[ vector_x.value, vector_y.value ] = [ 
								editor[key].x.toFixed(2), editor[key].y.toFixed(2) 
							];

						else [vector_x.value, vector_y.value] = ["",""];

					});

					watch( color_droplist, "onchange", function( property, event, key ){

						if ( key && editor[key] !== undefined && editor[key].isColor ) 

							[ color_r.value, color_g.value, color_b.value ] = [ 
								parseInt( 255*editor[ key ].r ).toFixed(0),
								parseInt( 255*editor[ key ].g ).toFixed(0),
								parseInt( 255*editor[ key ].b ).toFixed(0)
							];

						else [color_r.value, color_g.value, color_b.value] = ["","",""];

					});

					watch( texture_droplist, "onchange", function( property, event, map ){

						if ( !map || editor[map] == null || !editor[map].isTexture ) 
							return [vector_x.value, vector_y.value] = ["",""];

						var key = vector_droplist.value;

						if ( map === "normalMap" && key === "normalScale" 
						&& editor[ key ] && editor[ key ].isVector2 ) 

							[ vector_x.value, vector_y.value ] = [ 
								editor[key].x.toFixed(2), editor[key].y.toFixed(2) 
							];

						else [vector_x.value, vector_y.value] = ["",""];

					});

					watch( entity_droplist, "onchange", function( property, event, value ){
						editor.update( parseInt( value ) ); // important! id.
						callWatchers( key_droplist, "onchange", "change", key_droplist.value );
						callWatchers( color_droplist, "onchange", "change", color_droplist.value );
						callWatchers( vector_droplist, "onchange", "change", vector_droplist.value );
						callWatchers( texture_droplist, "onchange", "change", texture_droplist.value );
					});

				})();

			//	Tab keyboard inputs.

				(function(){

					var interval;

				//	keyInputs blur.

					color_r.addEventListener( "change", color_r.blur );
					color_g.addEventListener( "change", color_g.blur );
					color_b.addEventListener( "change", color_b.blur );
					vector_x.addEventListener( "change", vector_x.blur );
					vector_y.addEventListener( "change", vector_y.blur );
					text_input.addEventListener( "change", text_input.blur );
					value_input.addEventListener( "change", value_input.blur );

				//	keyInputControls.

					function enableKeyInputControls(){
						keyInputControls.isDisabled = false;
					}

					function disableKeyInputControls(){
						keyInputControls.isDisabled = true;
					}

					color_r.addEventListener( "blur", enableKeyInputControls );
					color_g.addEventListener( "blur", enableKeyInputControls );
					color_b.addEventListener( "blur", enableKeyInputControls );
					vector_x.addEventListener( "blur", enableKeyInputControls );
					vector_y.addEventListener( "blur", enableKeyInputControls );
					text_input.addEventListener( "blur", enableKeyInputControls );
					value_input.addEventListener( "blur", enableKeyInputControls );

					color_r.addEventListener( "focus", disableKeyInputControls );
					color_g.addEventListener( "focus", disableKeyInputControls );
					color_b.addEventListener( "focus", disableKeyInputControls );
					vector_x.addEventListener( "focus", disableKeyInputControls );
					vector_y.addEventListener( "focus", disableKeyInputControls );
					text_input.addEventListener( "focus", disableKeyInputControls );
					value_input.addEventListener( "focus", disableKeyInputControls );

				//	keyinputs change.

				//	Text input update editor value on keyinput change watch event.
					watch( text_input, "onchange", function(property, event, value){
						debugMode && console.log({item:"text input",event:event,"value":value});

						if ( !key_droplist.value ) return text_input.value = "";
						if ( !entity_droplist.value ) return text_input.value = "";

					//	"value" always comes as typeof "string".

						if ( value === "" )  return text_input.value = "";
						if ( value === "undefined" ) return text_input.value = "";

						var key = key_droplist.value;
						var value = text_input.value; // string.

						switch ( key ){

						//	Before change the editor[key] value add an undo state in undo queue.
						//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

							case "name":
								if ( editor[key] !== value ) {
									addtoUndo(); editor[ key ] = value; // important!
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
								}
							break;

							case "uuid":
							case "type":
							case "linecap":
							case "linejoin":
							case "wireframeLinecap":
								text_input.value = editor[ key ];
							break;

							default:
								[ value_input.value, text_input.value ] = ["",""];
							break;
						}

					});

				//	Value input update editor value on keyinput change watch event.
					watch( value_input, "onchange", function(property, event, value){
					//	debugMode && console.log({item:"value input",event:event,"value":value});

						if ( !key_droplist.value ) return value_input.value = "";
						if ( !entity_droplist.value ) return value_input.value = "";

					//	"value" always comes as typeof "string", (ecxept NaN, undefined?)

						if ( value === undefined ) return value_input.value = "";
						if ( value === "" ) return value_input.value = "";
						if ( value === "NaN" ) return value_input.value = "";
						if ( value === "undefined" ) return value_input.value = "";

						var key = key_droplist.value;

					//	disabled on key change.

						if ( typeof editor[key] === "string" ) value_input.value = "";

					//	enabled on key change.

						else if ( typeof editor[key] === "boolean" ) {

							if ( value === "false" ) value = 0;     // accept "false" string.
							else if ( value === "true" ) value = 1; // accept "true" string.
							else if ( isNaN(value) ) return value_input.value = editor[ key ]; // avoid to pass NaN value!
							else value = Number(value); // convert to number, important!

						//	Before change the editor[key] value add an undo state in undo queue.
						//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

							if ( editor[key] !== Boolean(value) ) {
								addtoUndo(); editor[key] = Boolean(value); // important!
								debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
							}

							value_input.value = editor[ key ]; // display value.
						}

						else if ( typeof editor[key] === "number" ) {

							if ( isNaN(value) ) return value_input.value = editor[ key ];
							if ( isNaN(editor[key]) ) return value_input.value = ""; // avoid to pass NaN value!

						//	Before change the editor[key] value add an undo state in undo queue.
						//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

							switch ( key ) {

								case "displacementScale":
								case "polygonOffsetUnits":
								case "polygonOffsetFactor":
									var value = THREE.Math.clamp(Number(value), -100, 100);
									if ( editor[key] !== value ) { addtoUndo(); editor[key] = Number(value); 
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "opacity":
								case "overdraw":
								case "alphaTest":
								case "reflectivity":
									var value = THREE.Math.clamp(Number(value), 0, 1);
									if ( editor[key] !== value ) { addtoUndo(); editor[key] = Number(value); 
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "refractionRatio":
									var value = THREE.Math.clamp(Number(value), -1, 1);
									if ( editor[key] !== value ) { addtoUndo(); editor[key] = Number(value); 
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "bumpScale":
								case "metalness":
								case "roughness":
								case "displacementBias":
								case "aoMapIntensity":
								case "envMapIntensity":
								case "emissiveIntensity":
								case "lightMapIntensity":
								case "wireframeLinewidth":
									var value = THREE.Math.clamp(Number(value), -10, 10);
									if ( editor[key] !== value ) { addtoUndo(); editor[key] = Number(value); 
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "linewidth":
									var value = THREE.Math.clamp(Number(value), 0, 100);
									if ( editor[key] !== value ) { addtoUndo(); editor[key] = Number(value); 
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "size":
								case "scale":
								case "gapSize":
								case "dashSize":
								case "shininess":
									var value = THREE.Math.clamp(Number(value), 0, 1000);
									if ( editor[key] !== value ) { addtoUndo(); editor[key] = Number(value); 
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "rotation":
									var value = DEG2RAD*THREE.Math.clamp(Number(value), -180, 180);
									if ( editor[key] !== value ) { addtoUndo(); editor[key] = Number(value); 
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
							//
								case "blending":
									if ( "0,1,2,3,4,5".split(",").includes(value) 
									&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
										debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "side":
									if ( "0,1,2".split(",").includes(value) 
									&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
										debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "vertexColors":
									if ( "0,1,2".split(",").includes(value) 
									&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
										debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "blendDst":
								case "blendSrc":
									if ( "200,201,202,203,204,205,206,207,208,209,210".split(",").includes(value)
									&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
										debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "blendEquation":
									if ( "100,101,102,103,104".split(",").includes(value)
									&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
										debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "depthFunc":
									if ( "0,1,2,3,4,5,6,7".split(",").includes(value)
									&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
										debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "normalMapType":
									if ( "0,1".includes(value)
									&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
										debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;
								case "combine":
									if ( "0,1,2".includes(value)
									&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
										debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
								break;

							}

							if ( key === "rotation" )
								value_input.value = RAD2DEG*editor[key].toFixed(1); // display value.
							else 
								value_input.value = editor[ key ]; // display value.
						}

					//

						else if ( typeof editor[key] === "undefined" ) {

						 //	string type values.

							if ( "uuid,type,linecap,linejoin,wireframeLinecap,name".split(",").includes(key) ) {

								value_input.value = "";

						//	boolean type values.

							} else if ( ("fog,lights,flatShading,transparent,depthTest,"
							+ "depthWrite,clipIntersection,clipShadows,colorWrite,polygonOffset,"
							+ "dithering,premultipliedAlpha,visible,needsUpdate,wireframe,"
							+ "skinning,morphTargets,morphNormals").split(",").includes(key) ) {

								if ( value === "false" ) value = 0;       // accepts "false" string.
								else if ( value === "true" ) value = 1;   // accepts "true" string.
								else if ( isNaN(value) ) return value_input.value = ""; // avoid to pass NaN value!
								else value = Number(value); // convert to number, important!

							//	Before change the editor[key] value add an undo state in undo queue.
							//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

								if ( editor[key] !== Boolean(value) ) {
									addtoUndo(); editor[key] = Boolean(value); // important!
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
								}
								
								value_input.value = editor[ key ]; // display value.

						//	number type values.

							} else if ( ("displacementScale,polygonOffsetUnits,polygonOffsetFactor,opacity,overdraw,"
							+ "alphaTest,reflectivity,refractionRatio,bumpScale,metalness,roughness,displacementBias,"
							+ "aoMapIntensity,envMapIntensity,emissiveIntensity,lightMapIntensity,wireframeLinewidth,"
							+ "linewidth,size,scale,gapSize,dashSize,shininess,rotation").split(",").includes(key) ) {

							//	Before change the editor[key] value add an undo state in undo queue.
							//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

								if ( isNaN(value) ) return value_input.value = ""; // avoid to pass NaN value!

								switch ( key ) {

									case "displacementScale":
									case "polygonOffsetUnits":
									case "polygonOffsetFactor":
										var value = THREE.Math.clamp(Number(value), -100, 100); // number.
									break;
									case "opacity":
									case "overdraw":
									case "alphaTest":
									case "reflectivity":
										var value = THREE.Math.clamp(Number(value), 0, 1); // number.
									break;
									case "refractionRatio":
										var value = THREE.Math.clamp(Number(value), -1, 1); // number.
									break;
									case "bumpScale":
									case "metalness":
									case "roughness":
									case "displacementBias":
									case "aoMapIntensity":
									case "envMapIntensity":
									case "emissiveIntensity":
									case "lightMapIntensity":
									case "wireframeLinewidth":
										var value = THREE.Math.clamp(Number(value), -10, 10); // number.
									break;
									case "linewidth":
										var value = THREE.Math.clamp(Number(value), 0, 100); // number.
									break;
									case "size":
									case "scale":
									case "gapSize":
									case "dashSize":
									case "shininess":
										var value = THREE.Math.clamp(Number(value), 0, 1000); // number.
									break;
									case "rotation":
										var value = DEG2RAD*THREE.Math.clamp(Number(value), -180, 180); // number.
									break;

								}

								if ( !isNaN(value) && editor[key] !== Number(value) ) {
									addtoUndo(); editor[key] = Number(value); // important!
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
								}

								value_input.value = editor[ key ]; // display value.

							} else if ( ("blending,side,vertexColors,blendDst,blendSrc,blendEquation,depthFunc,"
							+ "normalMapType,combine,polygonOffsetUnits,polygonOffsetFactor").split(",").includes(key) ) {

							//	Before change the editor[key] value add an undo state in undo queue.
							//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

								switch ( key ) {

									case "blending":
										if ( "0,1,2,3,4,5".split(",").includes(value) 
										&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
									break;
									case "side":
										if ( "0,1,2".split(",").includes(value) 
										&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
									break;
									case "vertexColors":
										if ( "0,1,2".split(",").includes(value) 
										&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
									break;
									case "blendDst":
									case "blendSrc":
										if ( "200,201,202,203,204,205,206,207,208,209,210".split(",").includes(value)
										&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
									break;
									case "blendEquation":
										if ( "100,101,102,103,104".split(",").includes(value)
										&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
									break;
									case "depthFunc":
										if ( "0,1,2,3,4,5,6,7".split(",").includes(value)
										&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
									break;
									case "normalMapType":
										if ( "0,1".includes(value)
										&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
									break;
									case "combine":
										if ( "0,1,2".includes(value)
										&& editor[key] !== Number(value) ) { addtoUndo(); editor[key] = Number(value); 
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); }
									break;
								}

								value_input.value = editor[ key ]; // display value.
							}

						} else [ value_input.value, text_input.value ] = ["",""];

					});

				//	Vector input (x) update editor vector value on keyinput change watch event.
					watch( vector_x, "onchange", function(property, event, value){
					//	debugMode && console.log({item:"vector x",event:event,"value":value});

						if ( key_droplist.value === "" ) return vector_x.value = "";
						if ( entity_droplist.value === "" ) return vector_x.value = "";

					//	"value" always comes as typeof "string".

						if ( value === undefined ) return vector_x.value = "";
						if ( value === "" ) return vector_x.value = "";
						if ( value === "NaN" ) return vector_x.value = "";
						if ( value === "undefined" ) return vector_x.value = "";

						var key = vector_droplist.value;

					//	disabled on key change.

						if ( editor[key] === undefined ) vector_x.value = "";
						else if ( !editor[key].isVector2 ) vector_x.value = "";
						else if ( isNaN(value) ) vector_x.value = editor[key].x.toFixed(2);

					//	enabled on key change.
					//	Before change the editor[key] value add an undo state in undo queue.
					//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

						else if ( ["normalScale"].includes(key) ) {

							var value = THREE.Math.clamp( Number(value), -100, 100 ); // number.

							if ( editor[key].x !== Number(value) ) { 
								addtoUndo(); editor[key].x = Number(value); // important!
								debugMode && console.log( "undo:", undo.length, "redo:", redo.length, "value:", value );
							}

							vector_x.value = editor[key].x.toFixed(2); // display value.
						}

					});


				//	Vector input (y) update editor vector value on keyinput change watch event.
					watch( vector_y, "onchange", function(property, event, value){
					//	debugMode && console.log({item:"vector y",event:event,"value":value});

						if ( key_droplist.value === "" ) return vector_y.value = "";
						if ( entity_droplist.value === "" ) return vector_y.value = "";

					//	"value" always comes as typeof "string".

						if ( value === undefined ) return vector_y.value = "";
						if ( value === "" ) return vector_y.value = "";
						if ( value === "NaN" ) return vector_y.value = "";
						if ( value === "undefined" ) return vector_y.value = "";

						var key = vector_droplist.value;

					//	disabled on key change.

						if ( editor[key] === undefined ) vector_y.value = "";
						else if ( !editor[key].isVector2 ) vector_y.value = "";
						else if ( isNaN(value) ) vector_y.value = editor[key].y.toFixed(2);

					//	enabled on key change.
					//	Before change the editor[key] value add an undo state in undo queue.
					//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

						else if ( ["normalScale"].includes(key) ) {

							var value = THREE.Math.clamp( Number(value), -100, 100 ); // number.

							if ( editor[key].y !== Number(value) ) { 
								addtoUndo(); editor[key].y = Number(value); // important!
								debugMode && console.log( "undo:", undo.length, "redo:", redo.length, "value:", value );
							}

							vector_y.value = editor[key].y.toFixed(2); // display value.
						}

					});


				//	Color input (r) update editor color value on keyinput change watch event.
					watch( color_r, "onchange", function(property, event, value){
						debugMode && console.log({item:"color r",event:event,"value":value});

						if ( color_droplist.value === "" ) return color_r.value = "";
						if ( entity_droplist.value === "" ) return color_r.value = "";

					//	"value" always comes as typeof "string".

						if ( value === "" ) return color_r.value = "";
						if ( value === "undefined" ) return color_r.value = "";

						var key = color_droplist.value;

					//	disabled on key change.

						if ( editor[key] === undefined ) value_input.value = "";
						else if ( !editor[key].isColor ) value_input.value = "";
						else if ( isNaN(value) ) color_r.value = (255*editor[key].r).toFixed(0);

					//	enabled on key change.
					//	Before change the editor[key] value add an undo state in undo queue.
					//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

						else if ( ["color","emissive","specular"].includes(key) ) {

							var value = THREE.Math.clamp( (Number(value) % 256) / 255, 0, 1 ); // normalize.

							if ( editor[key].r !== value ) { addtoUndo(); editor[key].r = value; // important!

								debugMode && console.log( "undo:", undo.length, "redo:", redo.length, "value:", value );
							}
						}

						color_r.value = Number(255*editor[key].r).toFixed(0); // display value.

					});

				//	Color input (g) update editor color value on keyinput change watch event.
					watch( color_g, "onchange", function(property, event, value){
						debugMode && console.log({item:"color g",event:event,"value":value});

						if ( color_droplist.value === "" ) return color_g.value = "";
						if ( entity_droplist.value === "" ) return color_g.value = "";

					//	"value" always comes as typeof "string".

						if ( value === "" ) return color_g.value = "";
						if ( value === "undefined" ) return color_g.value = "";

						var key = color_droplist.value;

					//	disabled on key change.

						if ( editor[key] === undefined ) value_input.value = "";
						else if ( !editor[key].isColor ) value_input.value = "";
						else if ( isNaN(value) ) color_g.value = (255*editor[key].g).toFixed(0);

					//	enabled on key change.
					//	Before change the editor[key] value add an undo state in undo queue.
					//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

						else if ( ["color","emissive","specular"].includes(key) ) {

							var value = THREE.Math.clamp( (Number(value) % 256) / 255, 0, 1 ); // normalize.

							if ( editor[key].g !== value ) { addtoUndo(); editor[key].g = value; // important!

								debugMode && console.log( "undo:", undo.length, "redo:", redo.length, "value:", value );
							}
						}

						color_g.value = Number(255*editor[key].g).toFixed(0); // display value.

					});

				//	Color input (b) update editor color value on keyinput change watch event.
					watch( color_b, "onchange", function(property, event, value){
						debugMode && console.log({item:"color b",event:event,"value":value});

						if ( color_droplist.value === "" ) return color_b.value = "";
						if ( entity_droplist.value === "" ) return color_b.value = "";

					//	"value" always comes as typeof "string".

						if ( value === "" ) return color_b.value = "";
						if ( value === "undefined" ) return color_b.value = "";

						var key = color_droplist.value;

					//	disabled on key change.

						if ( editor[key] === undefined ) value_input.value = "";
						else if ( !editor[key].isColor ) value_input.value = "";
						else if ( isNaN(value) ) color_b.value = (255*editor[key].b).toFixed(0);

					//	enabled on key change.
					//	Before change the editor[key] value add an undo state in undo queue.
					//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

						else if ( ["color","emissive","specular"].includes(key) ) {

							var value = THREE.Math.clamp( (Number(value) % 256) / 255, 0, 1 ); // normalize.

							if ( editor[key].b !== value ) { addtoUndo(); editor[key].b = value; // important!

								debugMode && console.log( "undo:", undo.length, "redo:", redo.length, "value:", value );
							}
						}

						color_b.value = Number(255*editor[key].b).toFixed(0); // display value.

					});

				})();

/*
				//	First "mousedown" event (mousedown, onWatchValue ) eventListener, sets the values in 
				//	the "watchValue" object and the ( mousedown, onWatchValue ) eventListener is removed.
				//	Last "click" event ( click, onMouseClick ) eventListener, changes the watchValue.value 
				//	and calls the watcher, which restore the (mousedown, onWatchValue ) eventListener.

					var watchValue = {
						key:undefined,    // editor key,
						value:undefined,  // editor[key].
						button:undefined, // current button.
						entity:undefined, // material.id,
					};

				//	Will trigger when clicking has finished (and a value has changed).
					watch( watchValue, "value", function( prop, action, value, oldValue ){
						debugMode && console.log({ event:"on click end", key:watchValue.key, "new value":value, "old value":oldValue });

						if ( watchValue.button == undefined ) return;
						if ( entity_droplist.value === "" ) return;

					//	Add event listener.
						watchValue.button && watchValue.button.addEventListener( "mousedown", onWatchValue ); // important!

					//	Add to undo.
						if ( watchValue.key && editor[ watchValue.key ] !== value ) {
						//	add to undo.
							addtoUndo(); debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); // undo.
						//	update editor value.
							editor[ watchValue.key ] = value; // update.
						}

					//	display editor value.
						if ( watchValue.key === "rotation" )  [value_input.value, text_input.value] = [ (RAD2DEG*editor[watchValue.key]).toFixed(1),""];
						else if (typeof value === "string" )  [text_input.value, value_input.value] = [ editor[ watchValue.key ],""]; // string.
						else if (typeof value === "number" )  [value_input.value, text_input.value] = [ editor[ watchValue.key ],""]; // number.
						else if (typeof value === "boolean" ) [value_input.value, text_input.value] = [ editor[ watchValue.key ],""]; // boolean.

					});

					function onWatchValue(){

						var button = this;
						if ( entity_droplist.value === "" ) return;

						watchValue.button = button;
						watchValue.key = key_droplist.value;
						watchValue.value = editor[ key_droplist.value ]; // editor[key].
						watchValue.entity = parseInt(entity_droplist.value);
						button.removeEventListener( "mousedown", onWatchValue ); // important!
					}
*/

			//	key/value mouse inputs.

				(function(){

					var interval;

				//	keep first, ignore next events.

					var state;
					function onfirstMouseDown(){
						state = {};
						var key = key_droplist.value;
						state.key = key;
						state.value = editor[ key ];
						state.json = editor.toJSON();
						console.log( "state:", state, "undo:", undo.length, "redo:", redo.length );
					//	Remove on firstMouseDown event listener.
						this.removeEventListener( "mousedown", onfirstMouseDown ); // important!
					};

					increase_v.addEventListener( "mousedown", onfirstMouseDown );
					decrease_v.addEventListener( "mousedown", onfirstMouseDown );

					increase_v.addEventListener( "mousedown", onMouseDown );
					decrease_v.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
					//	debugMode && console.log( "on MouseUp:", interval );
						clearTimeout( interval ); // important!
					});

					increase_v.addEventListener( "click", onMouseClick );
					decrease_v.addEventListener( "click", onMouseClick );

					function onMouseDown(){

						clearTimeout( interval ); // important!

						if ( !entity_droplist.value === "" ) return;

					//	disabled on mouse down.

						if ( key_droplist.value === "" ) return;
						if ( isNaN(editor[key_droplist.value]) ) return; // avoid to pass NaN value!

					//	enabled on mouse down.

						var button = this;
						var clock = new THREE.Clock();

						interval = setTimeout( function update() {

							var key = key_droplist.value;

							if ( isNaN(editor[key]) ) return; // avoid to pass NaN value!

							function updateFloatRotationValue(){
								var step = 0.1 * Math.PI/180; // 0.1 deg.
								var min = -Math.PI, max = Math.PI;
								var value = Number(editor[ key ]); // get value from editor.
								if ( button === increase_v ) value = THREE.Math.clamp( value+step, min, max );
								if ( button === decrease_v ) value = THREE.Math.clamp( value-step, min, max );
								value_input.value = ( RAD2DEG * ( editor[ key ] = value) ).toFixed(1); // string.
							}

							function updateFloatNumberValue(min, max, step){
								var value = Number(editor[ key ]); // get value from editor.
								if ( button === increase_v ) value = THREE.Math.clamp( value+step, min, max );
								if ( button === decrease_v ) value = THREE.Math.clamp( value-step, min, max );
								value_input.value = ( editor[key] = round(value, 2) ).toFixed(2);
							}

							function updateIntegerNumberValue(min, max){
								var value = parseInt(editor[ key ]); // get value from editor.
								if ( button === increase_v ) value = THREE.Math.clamp( ++value, min, max );
								if ( button === decrease_v ) value = THREE.Math.clamp( --value, min, max );
								value_input.value = ( editor[key] = parseInt(value) ).toFixed(0);
							}

							switch ( key ){

								case "polygonOffsetUnits":
								case "polygonOffsetFactor":
									updateIntegerNumberValue(-100, 100);
								break;
								case "displacementScale":
									updateFloatNumberValue(-100, 100, 1/100);
								break;
								case "bumpScale":
								case "metalness":
								case "roughness":
								case "displacementBias":
									updateFloatNumberValue(-10, 10, 1/100);
								break;
								case "refractionRatio":
									updateFloatNumberValue(-1, 1, 1/100);
								break;
								case "opacity":
								case "overdraw":
								case "alphaTest":
								case "reflectivity":
								case "wireframeLinewidth":
									updateFloatNumberValue(0, 1, 1/100);
								break;
								case "linewidth":
								case "aoMapIntensity":
								case "envMapIntensity":
								case "emissiveIntensity":
								case "lightMapIntensity":
									updateFloatNumberValue(0, 100, 1/100);
								break;
								case "size":
								case "scale":
								case "gapSize":
								case "dashSize":
								case "shininess":
									updateFloatNumberValue(0, 1000, 1/100);
								break;
								case "rotation":
									updateFloatRotationValue();
								break;
							}

							var dt = clock.getDelta();
							interval = setTimeout( update, dt );
						//	debugMode && console.log( "on mousedown:", interval );

						}, 500);
					}

					function onMouseClick(){

						clearTimeout( interval ); // important!

						if ( !entity_droplist.value === "" ) return;

					//	disabled on mouse click.

						if ( key_droplist.value === "" ) return;
						if ( key_droplist.value === "name" ) return;
						if ( key_droplist.value === "type" ) return;

					//	enabled on mouse click.

						var button = this;
						var key = key_droplist.value;

					//	if ( isNaN(editor[key]) ) value_input.value = ""; // avoid to pass NaN value!


					//	Before change the editor[key] value add an undo state in undo queue.
					//	Until now we has adding to Undo after the value has changed. That was mistake/bug! (TO FIX!)

						function updateFloatRotationValue(){
							var step = 0.1 * Math.PI/180; // 0.1 deg.
							var min = -Math.PI, max = Math.PI;
							var value = Number(editor[ key ]); // get value from editor, rad.
							if ( isNaN(value) ) return value_input.value = ""; // avoid to pass NaN editor[key] value.
							if ( button === increase_v ) value = THREE.Math.clamp( value+step, min, max ); // rad.
							if ( button === decrease_v ) value = THREE.Math.clamp( value-step, min, max ); // rad.
						//	Bypass watcher.
							if ( value !== state.value ) 
								interval = setTimeout( function(){ 
									state.json && undo.unshift( state.json ); // Add to undo.
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); 
									button.addEventListener( "mousedown", onfirstMouseDown ); // important!
								}, 250);
						//	update editor value.
							editor[ key ] = value; value_input.value = (RAD2DEG*editor[key]).toFixed(1); // display.
						}

						function updateFloatNumberValue(min, max, step){
							var value = Number(editor[ key ]); // get value from editor.
							if ( isNaN(value) ) return value_input.value = ""; // avoid to pass NaN editor[key] value.
							if ( button === increase_v ) value = THREE.Math.clamp( value+step, min, max );
							if ( button === decrease_v ) value = THREE.Math.clamp( value-step, min, max );
						//	Bypass watcher.
							if ( value !== state.value ) 
								interval = setTimeout( function(){ 
									state.json && undo.unshift( state.json ); // Add to undo.
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); 
									button.addEventListener( "mousedown", onfirstMouseDown ); // important!
								}, 250);
						//	update editor value.
							editor[ key ] = value; value_input.value = editor[key].toFixed(2); // display.
						}

						function updateIntegerNumberValue(min, max){
							var value = parseInt(editor[ key ]); // get value from editor.
							if ( isNaN(value) ) return value_input.value = ""; // avoid to pass NaN editor[key] value.
							if ( button === increase_v ) value = THREE.Math.clamp( ++value, min, max );
							if ( button === decrease_v ) value = THREE.Math.clamp( --value, min, max );
						//	Bypass watcher.
							if ( value !== state.value ) interval = setTimeout( function(){ 
								state.json && undo.unshift( state.json ); // Add to undo.
								debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); 
								button.addEventListener( "mousedown", onfirstMouseDown ); // important!
							}, 250);
						//	update editor value.
							value_input.value = editor[ key ] = value; // display.
						}

						function updateConstantStringValue( values ){
							var min = 0, max = values.length;
							var value = editor[ key ]; // string.
							var index = values.findIndex(function( item ){ return item === value; });
							if ( button === increase_v ) value = values[ ( ++index % max + max ) % max ]; // mod();
							if ( button === decrease_v ) value = values[ ( --index % max + max ) % max ]; // mod();
						//	Bypass watcher.
							if ( value !== state.value ) 
								interval = setTimeout( function(){ 
									state.json && undo.unshift( state.json ); // Add to undo.
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); 
									button.addEventListener( "mousedown", onfirstMouseDown ); // important!
								}, 250);
						//	update editor value.
							text_input.value = editor[ key ] = value; // display.
						}

						function updateConstantNumberValue( values ){
							var min = 0, max = values.length;
							var value = Number(editor[ key ]); // get value from editor.
							var index = values.findIndex(function( item ){ return item === value; });
							if ( button === increase_v ) value = values[ ( ++index % max + max ) % max ]; // mod();
							if ( button === decrease_v ) value = values[ ( --index % max + max ) % max ]; // mod();
						//	Bypass watcher.
							if ( value !== state.value ) 
								interval = setTimeout( function(){ 
									state.json && undo.unshift( state.json ); // Add to undo.
									debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); 
									button.addEventListener( "mousedown", onfirstMouseDown ); // important!
								}, 250);
						//	update editor value.
							value_input.value = editor[ key ] = value; // display.
						}

						switch ( key ){

						//	string:
							case "name":
							case "type":
								text_input.value = editor[ key ]; // disabled on mouse click.
							break;

							case "uuid": 
							//	Bypass watcher.
								(function(){
									var value = THREE.Math.generateUUID(); // string
								//	Bypass watcher.
									if ( value !== state.value ) 
										interval = setTimeout( function(){ 
											state.json && undo.unshift( state.json ); // Add to undo.
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); 
											button.addEventListener( "mousedown", onfirstMouseDown ); // important!
										}, 250);
								//	update editor value.
									text_input.value = editor[ key ] = value; // display.
								})();
							break;

							case "linecap":
							case "wireframeLinecap":
								updateConstantStringValue(["butt","round","square"]);
							break;
							case "linejoin":
								updateConstantStringValue(["bevel","round","miter"]);
							break;
							case "precision":
								updateConstantStringValue(["highp","mediump","lowp"]);
							break;

						//	boolean:
							case "fog":
							case "lights":
							case "flatShading":
							case "transparent":
							case "depthTest":
							case "depthWrite":
							case "clipIntersection":
							case "clipShadows":
							case "colorWrite":
							case "polygonOffset":
							case "dithering":
							case "premultipliedAlpha":
							case "visible":
							case "wireframe":
							case "skinning":
							case "morphTargets":
							case "morphNormals":
						//	case "needsUpdate":
							case "sizeAttenuation":
							//	Bypass watcher.
								(function(){
									var value = !editor[ key ]; // boolean.
								//	Bypass watcher.
									if ( value !== state.value ) 
										interval = setTimeout( function(){ 
											state.json && undo.unshift( state.json ); // Add to undo.
											debugMode && console.log( "undo:", undo.length, "redo:", redo.length ); 
											button.addEventListener( "mousedown", onfirstMouseDown ); // important!
										}, 250);
								//	update editor value.
									value_input.value = editor[ key ] = value; // display.
								})();
							break;

						//	number:
							case "blending":
								updateConstantNumberValue([
									THREE.NoBlending,THREE.NormalBlending,THREE.AdditiveBlending,
									THREE.SubtractiveBlending,THREE.MultiplyBlending,THREE.CustomBlending
								]);
							break;
							case "side":
								updateConstantNumberValue([THREE.FrontSide,THREE.BackSide,THREE.DoubleSide]);
							break;
							case "vertexColors":
								updateConstantNumberValue([THREE.NoColors,THREE.FaceColors,THREE.VertexColors]);
							break;
							case "blendDst":
							case "blendSrc":
								updateConstantNumberValue([THREE.ZeroFactor,THREE.OneFactor,THREE.SrcColorFactor,
									THREE.OneMinusSrcColorFactor,THREE.SrcAlphaFactor,THREE.OneMinusSrcAlphaFactor,
									THREE.DstAlphaFactor,THREE.OneMinusDstAlphaFactor,THREE.DstColorFactor,
									THREE.OneMinusDstColorFactor,THREE.SrcAlphaSaturateFactor
								]);
							break;
							case "blendEquation":
								updateConstantNumberValue([THREE.AddEquation,THREE.SubtractEquation,
									THREE.ReverseSubtractEquation,THREE.MinEquation,THREE.MaxEquation
								]);
							break;
							case "depthFunc":
								updateConstantNumberValue([THREE.NeverDepth,THREE.AlwaysDepth,THREE.LessDepth,
									THREE.LessEqualDepth,THREE.GreaterEqualDepth,THREE.GreaterDepth,THREE.NotEqualDepth
								]);
							break;
							case "normalMapType":
								updateConstantNumberValue([THREE.TangentSpaceNormalMap,THREE.ObjectSpaceNormalMap]);
							break;
							case "combine":
								updateConstantNumberValue([THREE.MultiplyOperation,THREE.MixOperation,THREE.AddOperation]);
							break;
						//
							case "polygonOffsetUnits":
							case "polygonOffsetFactor":
								updateIntegerNumberValue(-100, 100);
							break;
							case "displacementScale":
								updateFloatNumberValue(-100, 100, 1/100);
							break;
							case "bumpScale":
							case "metalness":
							case "roughness":
							case "displacementBias":
								updateFloatNumberValue(-10, 10, 1/100);
							break;
							case "refractionRatio":
								updateFloatNumberValue(-1, 1, 1/100);
							break;
							case "opacity":
							case "overdraw":
							case "alphaTest":
							case "reflectivity":
							case "wireframeLinewidth":
								updateFloatNumberValue(0, 1, 1/100);
							break;
							case "linewidth":
							case "aoMapIntensity":
							case "envMapIntensity":
							case "emissiveIntensity":
							case "lightMapIntensity":
								updateFloatNumberValue(0, 100, 1/100);
							break;
							case "depthPacking":
								//	???
							break;
							case "size":
							case "scale":
							case "gapSize":
							case "dashSize":
							case "shininess":
								updateFloatNumberValue(0, 1000, 1/100);
							break;
							case "rotation":
								updateFloatRotationValue();
							break;

							default:
								value_input.value = editor[key] || ""; // disabled on mouse click.
							break;
						}

						debugMode && console.log( "on Mouse Click:", interval );

					//	call watcher to add undo.
					//	interval = setTimeout( function(){
					//		watchValue.value = editor[ key ];
					//	}, 250);

					}

				})();

			//	vector mouse inputs.

				(function(){

					var interval;

				//	First "mousedown" event (mousedown, onWatchValue ) eventListener, sets the values in 
				//	the "watchValue" object and the ( mousedown, onWatchValue ) eventListener is removed.
				//	Last "click" event ( click, onMouseClick ) eventListener, changes the watchValue.value 
				//	and calls the watcher, which restore the (mousedown, onWatchValue ) eventListener.

					var watchValue = {
						entity:undefined, // material.id,
						button:undefined, // current button.
						key:undefined,    // editor key,
						value:undefined,  // editor[key].x
					};

				//	Initialize watchValue.
					watch( entity_droplist, "onchange", function( property, event, id ){
					//	debugMode && console.log({item:"droplist",event:event,"value":id});
					//	watchValue.button = increase_x; watchValue.key = vector_droplist.value;
					//	watchValue.value = editor[vector_droplist.value].x; watchValue.entity = id; 
					});

				//	Will trigger when clicking has finished (and value has changed).
					watch( watchValue, "value", function( prop, action, value, oldValue ){
						debugMode && console.log({ event:"on click end", "new value":value, "old value":oldValue });

						if ( watchValue.button == null ) return;
						if ( entity_droplist.value === "" ) return;

					//	Add event listener.
						watchValue.button && watchValue.button.addEventListener( "mousedown", onWatchValue ); // important!

					//	Add to undo.
						entity_droplist.value && addtoUndo(); // add to undo.
						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
					});

				//	keep first, ignore next events.
					increase_x.addEventListener( "mousedown", onWatchValue );
					decrease_x.addEventListener( "mousedown", onWatchValue );

					function onWatchValue(){

						var button = this;
						if ( entity_droplist.value === "" ) return;
						if ( vector_droplist.value === "" ) return;

						watchValue.button = button;
						watchValue.key = vector_droplist.value;
						watchValue.entity = parseInt(entity_droplist.value);
						watchValue.value = editor[vector_droplist.value].x; // editor[key].x
						button.removeEventListener( "mousedown", onWatchValue ); // important!
					}

					increase_x.addEventListener( "mousedown", onMouseDown );
					decrease_x.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
					//	debugMode && console.log( "on MouseUp:", interval );
						clearTimeout( interval ); // important!
					});

					increase_x.addEventListener( "click", onMouseClick );
					decrease_x.addEventListener( "click", onMouseClick );

					function onMouseDown(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse down.

						if ( vector_droplist.value === "" ) return;

					//	enabled on mouse down.

						var button = this;
						var clock = new THREE.Clock();

						interval = setTimeout( function update() {

							var key = vector_droplist.value;
							var step = 1/100, min = -100, max = 100;

							var value = Number(editor[ key ].x); // get value from editor.
							if ( button === increase_x ) value = THREE.Math.clamp( value+step, min, max );
							if ( button === decrease_x ) value = THREE.Math.clamp( value-step, min, max );
							vector_x.value = ( editor[ key ].x = round(value, 2) ).toFixed(2);

							var dt = clock.getDelta();
							interval = setTimeout( update, dt );
						//	debugMode && console.log( "on Update:", interval );


						}, 500);

					}

					function onMouseClick(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse click.

						if ( vector_droplist.value === "" ) return;

					//	enabled on mouse click.

						var button = this;
						var key = vector_droplist.value;
						var step = 1/100, min = -100, max = 100;

						var value = Number(editor[ key ].x); // get value from editor.
						if ( button === increase_x ) value = THREE.Math.clamp( value+step, min, max );
						if ( button === decrease_x ) value = THREE.Math.clamp( value-step, min, max );
						vector_x.value = ( editor[ key ].x = round(value, 2) ).toFixed(2);

						debugMode && console.log( "on Mouse Click:", interval );

					//	call watcher to add undo.
						interval = setTimeout( function(){
							watchValue.value = editor[key].x;
						}, 250);

					}

				})();

				(function(){

					var interval;

					var watchValue = {
						entity:undefined, // material.id,
						button:undefined, // current button.
						key:undefined,    // editor key,
						value:undefined,  // editor[key].y
					};

				//	Initialize watchValue.
					watch( entity_droplist, "onchange", function( property, event, id ){
					//	debugMode && console.log({item:"droplist",event:event,"value":id});
					//	watchValue.button = increase_y; watchValue.key = vector_droplist.value;
					//	watchValue.value = editor[vector_droplist.value].y; watchValue.entity = id; 
					});

				//	Will trigger when clicking has finished (and value has changed).
					watch( watchValue, "value", function( prop, action, value, oldValue ){
						debugMode && console.log({ event:"on click end", "new value":value, "old value":oldValue });

						if ( watchValue.button == null ) return;
						if ( entity_droplist.value === "" ) return;

					//	Add event listener.
						watchValue.button && watchValue.button.addEventListener( "mousedown", onWatchValue ); // important!

					//	Add to undo.
						entity_droplist.value && addtoUndo(); // add to undo.
						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
					});

				//	keep first, ignore next events.
					increase_y.addEventListener( "mousedown", onWatchValue );
					decrease_y.addEventListener( "mousedown", onWatchValue );

					function onWatchValue(){

						var button = this;
						if ( entity_droplist.value === "" ) return;
						if ( vector_droplist.value === "" ) return;

						watchValue.button = button;
						watchValue.key = vector_droplist.value;
						watchValue.entity = parseInt(entity_droplist.value);
						watchValue.value = editor[vector_droplist.value].y; // editor[key].y
						button.removeEventListener( "mousedown", onWatchValue ); // important!
					}

					increase_y.addEventListener( "mousedown", onMouseDown );
					decrease_y.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
					//	debugMode && console.log( "on MouseUp:", interval );
						clearTimeout( interval ); // important!
					});

					increase_y.addEventListener( "click", onMouseClick );
					decrease_y.addEventListener( "click", onMouseClick );

					function onMouseDown(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse down.

						if ( vector_droplist.value === "" ) return;
						//	return [ vector_x.value, vector_y.value ] = ["",""];

					//	enabled on mouse down.

						var button = this;
						var clock = new THREE.Clock();

						interval = setTimeout( function update() {

							var key = vector_droplist.value;
							var step = 1/100, min = -100, max = 100;

							var value = Number(editor[ key ].y); // get value from editor.
							if ( button === increase_y ) value = THREE.Math.clamp( value+step, min, max );
							if ( button === decrease_y ) value = THREE.Math.clamp( value-step, min, max );
							vector_y.value = ( editor[ key ].y = round(value, 2) ).toFixed(2);

							var dt = clock.getDelta();
							interval = setTimeout( update, dt );
						//	debugMode && console.log( "on Update:", interval );

						}, 500);

					}

					function onMouseClick(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse click.

						if ( vector_droplist.value === "" ) return;
						//	return [ vector_x.value, vector_y.value ] = ["",""];

					//	enabled on mouse click.

						var button = this;
						var key = vector_droplist.value;
						var step = 1/100, min = -100, max = 100;

						var value = Number(editor[ key ].y); // get value from editor.
						if ( button === increase_y ) value = THREE.Math.clamp( value+step, min, max );
						if ( button === decrease_y ) value = THREE.Math.clamp( value-step, min, max );
						vector_y.value = ( editor[ key ].y = round(value, 2) ).toFixed(2);

						debugMode && console.log( "on Mouse Click:", interval );

					//	call watcher to add undo.
						interval = setTimeout( function(){
							watchValue.value = editor[key].y;
						}, 250);

					}

				})();

			//	color mouse inputs.

				(function(){

					var interval;

				//	First "mousedown" event (mousedown, onWatchValue ) eventListener, sets the values in 
				//	the "watchValue" object and the ( mousedown, onWatchValue ) eventListener is removed.
				//	Last "click" event ( click, onMouseClick ) eventListener, changes the watchValue.value 
				//	and calls the watcher, which restore the (mousedown, onWatchValue ) eventListener.

					var watchValue = {
						entity:undefined, // material.id,
						button:undefined, // current button.
						key:undefined,    // editor key,
						value:undefined,  // editor[key].r
					};

				//	Initialize watchValue.
					watch( entity_droplist, "onchange", function( property, event, id ){
					//	debugMode && console.log({item:"droplist",event:event,"value":id});
					//	watchValue.button = increase_r; watchValue.key = color_droplist.value;
					//	watchValue.value = editor[color_droplist.value].r; watchValue.entity = id; 
					});

				//	Will trigger when clicking has finished (and value has changed).
					watch( watchValue, "value", function( prop, action, value, oldValue ){
						debugMode && console.log({ event:"on click end", "new value":value, "old value":oldValue });

						if ( watchValue.button == null ) return;
						if ( entity_droplist.value === "" ) return;

					//	Add event listener.
						watchValue.button && watchValue.button.addEventListener( "mousedown", onWatchValue ); // important!

					//	Add to undo.
						entity_droplist.value && addtoUndo(); // add to undo.
						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
					});

				//	keep first, ignore next events.
					increase_r.addEventListener( "mousedown", onWatchValue );
					decrease_r.addEventListener( "mousedown", onWatchValue );

					function onWatchValue(){

						var button = this;
						if ( entity_droplist.value === "" ) return;
						if ( color_droplist.value  === "" ) return;

						watchValue.button = button;
						watchValue.key = color_droplist.value;
						watchValue.entity = parseInt(entity_droplist.value); // material.id,
						watchValue.value = editor[color_droplist.value].r;   // editor[key].r
						button.removeEventListener( "mousedown", onWatchValue ); // important!
					}

					increase_r.addEventListener( "mousedown", onMouseDown );
					decrease_r.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
					//	debugMode && console.log( "on MouseUp:", interval );
						clearTimeout( interval ); // important!
					});

					increase_r.addEventListener( "click", onMouseClick );
					decrease_r.addEventListener( "click", onMouseClick );

					function onMouseDown(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse down.

						if ( color_droplist.value === "" ) return;

					//	enabled on mouse down.

						var button = this;
						var clock = new THREE.Clock();

						interval = setTimeout( function update() {

							var key = color_droplist.value;
							var min = 0, max = 1, step = 1/255;

							var value = Number(editor[ key ].r); // get value from editor.
							if ( button === increase_r ) value = THREE.Math.clamp( value+step, min, max );
							if ( button === decrease_r ) value = THREE.Math.clamp( value-step, min, max );
							color_r.value = parseInt( 255 * ( editor[ key ].r = value ));

							var dt = clock.getDelta();
							interval = setTimeout( update, dt );
						//	debugMode && console.log( "on Update:", interval );

						}, 500);

					}

					function onMouseClick(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse click.

						if ( color_droplist.value === "" ) return;

					//	enabled on mouse click.

						var button = this;
						var key = color_droplist.value;
						var min = 0, max = 1, step = 1/255;

						var value = Number(editor[ key ].r); // get value from editor.
						if ( button === increase_r ) value = THREE.Math.clamp( value+step, min, max );
						if ( button === decrease_r ) value = THREE.Math.clamp( value-step, min, max );
						color_r.value = parseInt( 255 * ( editor[ key ].r = value ));

						debugMode && console.log( "on Mouse Click:", interval );

					//	call watcher to add undo.
						interval = setTimeout( function(){
							watchValue.value = editor[key].r;
						}, 250);

					}

				})();

				(function(){

					var interval;

					var watchValue = {
						entity:undefined, // material.id,
						button:undefined, // current button.
						key:undefined,    // editor key,
						value:undefined,  // editor[key].g
					};

				//	Initialize watchValue.
					watch( entity_droplist, "onchange", function( property, event, id ){
					//	debugMode && console.log({item:"droplist",event:event,"value":id});
					//	watchValue.button = increase_g; watchValue.key = color_droplist.value;
					//	watchValue.value = editor[color_droplist.value].g; watchValue.entity = id; 
					});

				//	Will trigger when clicking has finished (and value has changed).
					watch( watchValue, "value", function( prop, action, value, oldValue ){
						debugMode && console.log({ event:"on click end", "new value":value, "old value":oldValue });

						if ( watchValue.button == null ) return;
						if ( entity_droplist.value === "" ) return;

					//	Add event listener.
						watchValue.button && watchValue.button.addEventListener( "mousedown", onWatchValue ); // important!

					//	Add to undo.
						entity_droplist.value && addtoUndo(); // add to undo.
						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
					});

				//	keep first, ignore next events.
					increase_g.addEventListener( "mousedown", onWatchValue );
					decrease_g.addEventListener( "mousedown", onWatchValue );

					function onWatchValue(){

						var button = this;
						if ( entity_droplist.value === "" ) return;
						if ( color_droplist.value  === "" ) return;

						watchValue.button = button;
						watchValue.key = color_droplist.value;
						watchValue.entity = parseInt(entity_droplist.value); // material.id,
						watchValue.value = editor[color_droplist.value].g;   // editor[key].g
						button.removeEventListener( "mousedown", onWatchValue ); // important!
					}

					increase_g.addEventListener( "mousedown", onMouseDown );
					decrease_g.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
					//	debugMode && console.log( "on MouseUp:", interval );
						clearTimeout( interval ); // important!
					});

					increase_g.addEventListener( "click", onMouseClick );
					decrease_g.addEventListener( "click", onMouseClick );

					function onMouseDown(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse down.

						if ( color_droplist.value === "" ) return;

					//	enabled on mouse down.

						var button = this;
						var clock = new THREE.Clock();

						interval = setTimeout( function update() {

							var key = color_droplist.value;
							var min = 0, max = 1, step = 1/255;

							var value = Number(editor[ key ].g); // get value from editor.
							if ( button === increase_g ) value = THREE.Math.clamp( value+step, min, max );
							if ( button === decrease_g ) value = THREE.Math.clamp( value-step, min, max );
							color_g.value = parseInt( 255 * ( editor[ key ].g = value ));

							var dt = clock.getDelta();
							interval = setTimeout( update, dt );
						//	debugMode && console.log( "on Update:", interval );

						}, 500);

					}

					function onMouseClick(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse click.

						if ( color_droplist.value === "" ) return;

					//	enabled on mouse click.

						var button = this;
						var key = color_droplist.value;
						var min = 0, max = 1, step = 1/255;

						var value = Number(editor[ key ].g); // get value from editor.
						if ( button === increase_g ) value = THREE.Math.clamp( value+step, min, max );
						if ( button === decrease_g ) value = THREE.Math.clamp( value-step, min, max );
						color_g.value = parseInt( 255 * ( editor[ key ].g = value ));

						debugMode && console.log( "on Mouse Click:", interval );

					//	call watcher to add undo.
						interval = setTimeout( function(){
							watchValue.value = editor[key].g;
						}, 250);

					}

				})();

				(function(){

					var interval;

					var watchValue = {
						entity:undefined, // material.id,
						button:undefined, // current button.
						key:undefined,    // editor key,
						value:undefined,  // editor[key].b
					};

				//	Initialize watchValue.
					watch( entity_droplist, "onchange", function( property, event, id ){
					//	debugMode && console.log({item:"droplist",event:event,"value":id});
					//	watchValue.button = increase_b; watchValue.key = color_droplist.value;
					//	watchValue.value = editor[color_droplist.value].b; watchValue.entity = id; 
					});

				//	Will trigger when clicking has finished (and value has changed).
					watch( watchValue, "value", function( prop, action, value, oldValue ){
						debugMode && console.log({ event:"on click end", "new value":value, "old value":oldValue });

						if ( watchValue.button == null ) return;
						if ( entity_droplist.value === "" ) return;

					//	Add event listener.
						watchValue.button && watchValue.button.addEventListener( "mousedown", onWatchValue ); // important!

					//	Add to undo.
						entity_droplist.value && addtoUndo(); // add to undo.
						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
					});

				//	keep first, ignore next events.
					increase_b.addEventListener( "mousedown", onWatchValue );
					decrease_b.addEventListener( "mousedown", onWatchValue );

					function onWatchValue(){

						var button = this;
						if ( entity_droplist.value === "" ) return;
						if ( color_droplist.value  === "" ) return;

						watchValue.button = button;
						watchValue.key = color_droplist.value;
						watchValue.entity = parseInt(entity_droplist.value); // material.id,
						watchValue.value = editor[color_droplist.value].b;   // editor[key].b
						button.removeEventListener( "mousedown", onWatchValue ); // important!
					}

					increase_b.addEventListener( "mousedown", onMouseDown );
					decrease_b.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
					//	debugMode && console.log( "on MouseUp:", interval );
						clearTimeout( interval ); // important!
					});

					increase_b.addEventListener( "click", onMouseClick );
					decrease_b.addEventListener( "click", onMouseClick );

					function onMouseDown(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse down.

						if ( color_droplist.value === "" ) return;

					//	enabled on mouse down.

						var button = this;
						var clock = new THREE.Clock();

						interval = setTimeout( function update() {

							var key = color_droplist.value;
							var min = 0, max = 1, step = 1/255;

							var value = Number(editor[ key ].b); // get value from editor.
							if ( button === increase_b ) value = THREE.Math.clamp( value+step, min, max );
							if ( button === decrease_b ) value = THREE.Math.clamp( value-step, min, max );
							color_b.value = parseInt( 255 * ( editor[ key ].b = value ));

							var dt = clock.getDelta();
							interval = setTimeout( update, dt );
						//	debugMode && console.log( "on Update:", interval );

						}, 500);

					}

					function onMouseClick(){

						clearTimeout( interval ); // important!

						if ( entity_droplist.value === "" ) return;

					//	disabled on mouse click.

						if ( color_droplist.value === "" ) return;

					//	enabled on mouse click.

						var button = this;
						var key = color_droplist.value;
						var min = 0, max = 1, step = 1/255;

						var value = Number(editor[ key ].b); // get value from editor.
						if ( button === increase_b ) value = THREE.Math.clamp( value+step, min, max );
						if ( button === decrease_b ) value = THREE.Math.clamp( value-step, min, max );
						color_b.value = parseInt( 255 * ( editor[ key ].b = value ));

						debugMode && console.log( "on Mouse Click:", interval );

					//	call watcher to add undo.
						interval = setTimeout( function(){
							watchValue.value = editor[key].b;
						}, 250);

					}

				})();










			//	Material Editor Watchers.
			//	Watch each object/property individually.
			//	Synchronize material with editor (brige).

				(function( editor ){

					var interval;
					var material; // important!

					watch( entity_droplist, "onchange", function( property, event, value ){
						material = material_entities.getMaterialById( value ); // material.id.
						debugMode && console.log({item:"droplist",event:event,"material":material});
					});
					
				//	Vector.
					watch( editor.normalScale, ["x","y"], function( v, action, value ){
						if (material && material.normalScale) material.normalScale[v] = Number(editor.normalScale[v]); // copy.
					});

				//	Colors.
					watch( editor.color, ["r","g","b"], function( c, action, value ){
						if (material && material.color) material.color[c] = Number(editor.color[c]); // copy.
					});
					watch( editor.emissive, ["r","g","b"], function( c, action, value ){
						if (material && material.emissive) material.emissive[c] = Number(editor.emissive[c]); // copy.
					});
					watch( editor.specular, ["r","g","b"], function( c, action, value ){
						if (material && material.specular) material.specular[c] = Number(editor.specular[c]); // copy.
					});

				//	String.
					watch( editor, "name", function( key, action, value ){
						if ( material ) material[key] = String(editor[key]); // copy.
					});
					watch( editor, "uuid", function( key, action, value ){
						if ( material ) material[key] = String(editor[key]); // copy.
					});


				//	Values.
					watch( editor, "side", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "visible", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					watch( editor, "opacity", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "alphaTest", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					watch( editor, "transparent", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					watch( editor, "premultipliedAlpha", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});

					watch( editor, "fog", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					watch( editor, "lights", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					watch( editor, "dithering", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					watch( editor, "colorWrite", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					watch( editor, "flatShading", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});

					watch( editor, "overdraw", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "vertexColors", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "blending", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "blendSrc", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "blendDst", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "blendEquation", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "blendSrcAlpha", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "blendDstAlpha", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "blendEquationAlpha", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});
					watch( editor, "depthFunc", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});

					watch( editor, "wireframe", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					watch( editor, "wireframeLinecap", function( key, action, value ){
						if ( material ) material[key] = String(editor[key]); // copy.
					});
					watch( editor, "wireframeLinejoin", function( key, action, value ){
						if ( material ) material[key] = String(editor[key]); // copy.
					});
					watch( editor, "wireframeLinewidth", function( key, action, value ){
						if ( material ) material[key] = Number(editor[key]); // copy.
					});

					watch( editor, "precision", function( key, action, value ){
						if ( material ) material[key] = String(editor[key]); // copy.
					});

				//	Material needsUpdate button.

					watch( editor, "needsUpdate", function( key, action, value ){
						if ( material ) material[key] = Boolean(editor[key]); // copy.
					});
					needsUpdate_button.addEventListener( "click", function(){
						if ( material ) material.needsUpdate = true;
					});

				})( editor.reset() ); // important! (reset initializes editor)

				return editor; // important!

			})();

		</script>

		<script src="/ecs/engine/editor/TextureTab.js"></script>
		<script src="/ecs/engine/editor/ViewportTab.js"></script>

		<script>

			TabUI.Material.role.classList.add("active");
			TabUI.Material.tab.classList.add("in","active");

		//

			localPlayer.controller.movementSpeed = 10;

		//	Entities.

		//	debugMode && (function(){
		//		var r = 1;
		//		var geometry = new THREE.BoxGeometry(r,r,r);
		//		var material = new THREE.MeshLambertMaterial();
		//		var cube = new THREE.Mesh(geometry, material);
		//		cube.name = "local player cube";
		//		var geometry = new THREE.SphereGeometry(0.7,8,12);
		//		var material = new THREE.MeshLambertMaterial();
		//		var sphere = new THREE.Mesh(geometry, material);
		//		sphere.name = "local player sphere";
		//	//	cube.add( sphere );
		//		localPlayer.add( cube );
		//	})();

		//	box coluctions.

			debugMode && (function(){

				var material = new THREE.MeshStandardMaterial({name:"mtl00"});
				var maps = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
				maps += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
				material.envMap = new THREE.CubeTexture();
				maps.split(",").forEach( function( key ){
					if ( key !== "envMap" ) material[ key ] = new THREE.Texture();
				}); debugMode && console.log( material );
				material_entities.add( material );
			})();

		//	box coluctions.

			debugMode && (function(){

				(function(){
					var w = 10; var h = 5;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					octree.importThreeMesh( new THREE.Mesh(box) );
					var geometry = new THREE.EdgesGeometry( box );
					var material = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 1";
					scene.add( segments );
				})();

				(function(){
					var w = 10, h = 20;
					var x = 10, y = h/2, z = -4;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 1";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 2";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

				(function(){
					var w = 12, h = 10;
					var x = 15, y = h/2, z = -11;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 2";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 3";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

				(function(){
					var w = 8, h = 10;
					var x = -9, y = h/2, z = 5;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 3";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 4";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

				(function(){
					var w = 12, h = 20, d = 2;
					var x = -14, y = h/2, z = 10;
					var box = new THREE.BoxGeometry(w,h,d);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 4";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 5";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

				(function(){
					var w = 4, h = 20, d = 20;
					var x = -17, y = h/2, z = 12;
					var box = new THREE.BoxGeometry(w,h,d);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 5";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 6";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

			//	var groupA = new THREE.Object3D();
			//	var groupB = new THREE.Object3D();

			//	groupA.add( scene.getObjectByName("building 1").clone() );
			//	groupA.add( scene.getObjectByName("building 2").clone() );
			//	groupB.add( scene.getObjectByName("building 3").clone() );
			//	groupB.add( scene.getObjectByName("building 4").clone() );
			//	groupB.add( scene.getObjectByName("building 5").clone() );

			})();

		</script>

		<script>

		//	Add entities.

		//	Add Object3D entities.
			scene.traverse(function( object ){
				entities.add( object );
			});

		//	Add Material entities.
			entities.forEach( function( entity ){

			//	It looks in "entities" manager only.
			//	It looks the root Object3D, but not children.

				var object = scene.getObjectById( entity.id );
				if ( !object || !object.material ) return; // important!

				if ( Array.isArray( object.material ) )
					object.material.forEach( addtoManager );
				else 
					addtoManager( object.material );

				function addtoManager( material ){
					rename( material );
					addEntity( material );
				}

				function rename( material ){
					if ( material.name ) return;
					material.name = "mtl"+material.id;;
				}

				function addEntity( material ){
					var included = material_entities.includes( material );
					debugMode && console.log( "included:", included );
					if ( !included ) material_entities.add( material );
				}
			});

		//	Add Texture entities.
			material_entities.forEach( function( material ){
				for ( var name in material ) (function( key ){
					material[key] && material[key].isTexture 
					&& texture_entities.add( material[ key ] );
				})( name );
			});

			console.log( {"object3DEditor": object3DEditor} ); // debug!
			console.log( {"materialEditor": materialEditor} ); // debug!
			console.log( {"textureEditor" : textureEditor } ); // debug!

		</script>

		<script>
/*
					text_input.addEventListener( "change", function(){

						if ( !key_droplist.value ) return text_input.value = "";
						if ( !entity_droplist.value ) return text_input.value = "";

						var key = key_droplist.value;
						var value = text_input.value; // string.

						if ( key && value !== "" && value !== "undefined" ) 

							switch ( key ){

								case "name":
									editor[ key ] = value;
								break;

								case "uuid":
								case "type":
								case "linecap":
								case "linejoin":
								case "wireframeLinecap":
									text_input.value = editor[ key ];
								break;

								default:
									[ value_input.value, text_input.value ] = ["",""];
								break;
							}

						else [ value_input.value, text_input.value ] = ["",""];

					//	TODO: add to undo.

					});

					value_input.addEventListener( "change", function(){

						if ( !key_droplist.value ) return value_input.value = "";
						if ( !entity_droplist.value ) return value_input.value = "";

						var key = key_droplist.value;
						var value = Number(value_input.value); // number.

						if ( isNaN(value) ) return value_input.value = "";

					//	disabled on key change.

						if ( key && editor[key] !== undefined )

							if ( typeof editor[key] === "string" ) value_input.value = "";
							if ( typeof editor[key] === "number" ) value_input.value = value;
							if ( typeof editor[key] === "boolean" ) value_input.value = Boolean(value);

						else if ( key && editor[key] === undefined )

							switch ( key ){

							//	string:
								case "uuid":
								case "type":
								case "linecap":
								case "linejoin":
								case "wireframeLinecap":
								case "name":
									value_input.value = "";
								break;

							//	number:
								case "blending":
								case "side":
								case "vertexColors":
								case "opacity":
								case "blendSrc":
								case "blendDst":
								case "blendEquation":
								case "depthFunc":
								case "polygonOffsetFactor":
								case "polygonOffsetUnits":
								case "alphaTest,overdraw":
								case "displacementScale":
								case "metalness":
								case "roughness":
								case "bumpScale":
								case "refractionRatio":
								case "displacementBias":
								case "normalMapType":
								case "aoMapIntensity":
								case "envMapIntensity":
								case "emissiveIntensity":
								case "lightMapIntensity":
								case "wireframeLinewidth":
								case "reflectivity":
								case "combine":
								case "linewidth":
								case "shininess":
								case "depthPacking":
								case "scale":
								case "gapSize":
								case "dashSize":
								case "size":
								case "rotation":
								case "sizeAttenuation":
									editor[ key ] = value;
								break;

							//	boolean:
								case "fog":
								case "lights":
								case "flatShading":
								case "transparent":
								case "depthTest":
								case "depthWrite":
								case "clipIntersection":
								case "clipShadows":
								case "colorWrite":
								case "polygonOffset":
								case "dithering":
								case "premultipliedAlpha":
								case "visible":
								case "needsUpdate":
								case "wireframe":
								case "skinning":
								case "morphTargets":
								case "morphNormals":
									editor[ key ] = Boolean(value);
								break;

								default:
									[ value_input.value, text_input.value ] = ["",""];
								break;
							}

						else [ value_input.value, text_input.value ] = ["",""];

					//	TODO: add to undo.

					});

					vector_x.addEventListener( "change", onScaleInput )
					vector_y.addEventListener( "change", onScaleInput )

					function onScaleInput(){

						if ( this.value === "" ) return;
						if ( this.value == null ) return this.value = "";

						var key = vector_droplist.value;
						var map = texture_droplist.value;

						if ( key !== "normalScale" || map !== "normalMap") 
							return [vector_x.value, vector_y.value] = ["",""];

						if ( !editor.normalScale || !editor.normalScale.isVector2 )
							return [vector_x.value, vector_y.value] = ["",""];

						if ( editor.normalScale && editor.normalScale.isVector2 ) {

							var x = Number( vector_x.value ); // number. 
							if ( isNaN(x) ) vector_x.value = "";
							else editor.normalScale.x = x;

							var y = Number( vector_y.value ); // number. 
							if ( isNaN(y) ) vector_y.value = "";
							else editor.normalScale.y = y;

						}

					//	TODO: add to undo.

					}

					color_r.addEventListener( "change", onColorInput )
					color_g.addEventListener( "change", onColorInput )
					color_b.addEventListener( "change", onColorInput )

					function onColorInput(){

						if ( this.value === "" ) return;
						if ( this.value == null ) return this.value = "";

						if ( !entity_droplist.value || !color_droplist.value ) {
							[color_r.value, color_g.value, color_b.value] = ["","",""]; return;
						}

						var key = color_droplist.value;

						if ( key !== "color" || key !== "emissive" || key !== "specular" ) {
							[color_r.value, color_g.value, color_b.value] = ["","",""]; return;
						}

						var value = THREE.Math.clamp( Number(this.value), 0, 255) ;

						if ( editor[key] && editor[key].isColor ) {

							if ( isNaN(value) ) {
								if ( this === color_r ) color_r.value = parseInt(255*editor[key].r);
								if ( this === color_g ) color_g.value = parseInt(255*editor[key].g);
								if ( this === color_b ) color_b.value = parseInt(255*editor[key].b);
							} else {
								if ( this === color_r ) editor[key].r = Number(value)/255;
								if ( this === color_g ) editor[key].g = Number(value)/255;
								if ( this === color_b ) editor[key].b = Number(value)/255;
							}

						} else [color_r.value, color_g.value, color_b.value] = ["","",""];

					//	TODO: add to undo.

					}

*/
		</script>
	</body>
</html>
