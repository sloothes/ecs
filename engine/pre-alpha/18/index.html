<!DOCTYPE html>
<html lang="en">
	<head>

		<title>Legacy ECS Engine (pre-alpha 0.18)</title>

		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">
		<link rel="stylesheet" href="/css/jcrop.css">

		<script src="/js/watch.js"></script>
		<script src="/js/Objectid.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>
		<script src="/js/jcrop.js"></script>

		<style>

			body {
				margin: 0px;
				font-size: 13px;
				font-family: sans-serif;
				background-repeat: repeat;
				background-image: url("https://i.imgur.com/rnZZU0i.png") !important;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-matcap,
			.btn-terrain {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}

			.btn-matcap + .btn-matcap,
			.btn-terrain + .btn-terrain {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/ecs/js/three.js"></script>
		<script src="/ecs/js/TabUI.js"></script>
		<script src="/ecs/js/MeshWalk.js"></script>
		<script src="/ecs/js/UVsDebug.js"></script>
		<script src="/ecs/js/FBXLoader.js"></script>
		<script src="/ecs/js/VirtualInput.js"></script>
		<script src="/ecs/js/KeyboardState.js"></script>
		<script src="/ecs/js/EditorControls.js"></script>
		<script src="/ecs/js/camera-controls.js"></script>
		<script src="/ecs/js/SubdivisionModifier.js"></script>
		<script src="/ecs/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

		<script>

			debugMode = true;
			const Signal = signals.Signal;

		//	TabUI.

			(function(){

				var sidePanel = createSidePanel();
				document.body.appendChild( sidePanel );

			})();

		</script>

		<script src="/ecs/engine/core/enviroment.js"></script>
		<script src="/ecs/engine/core/entity.js"></script>
		<script src="/ecs/engine/core/helpers.js"></script>
		<script src="/ecs/engine/core/localPlayer.js"></script>
		<script src="/ecs/engine/core/cameraControls.js"></script>
		<script src="/ecs/engine/core/keyboardState.js"></script>
		<script src="/ecs/engine/core/keyInputControls.js"></script>
		<script src="/ecs/engine/core/joystickControls.js"></script>
		<script src="/ecs/engine/core/keyboard.js"></script>
		<script src="/ecs/engine/editor/EditorTab.js"></script>
		<script src="/ecs/engine/editor/MaterialTab.js"></script>
		<script src="/ecs/engine/editor/MaterialManager.js"></script>
		<script src="/ecs/engine/editor/MaterialEditor.js"></script>
		<script src="/ecs/engine/editor/TextureTab.js"></script>

		<script>

			//	TextureTab.js
			//	TextureManager.js

		</script>

		<script>

		//	TextureEditor Class.

		//	Pros of using TextureEditor class.
			//	Keeps editor clean. 
			//	Defines methods in prototype.

		//	Cons of using TextureEditor class.
			//	Difficult to display values after undo/redo.
			//	Need to parse undo/redo arrays in editor.undo/redo method.

			function TextureEditor(){
				Object.assign( this, new THREE.Texture().toJSON() );
			}

			TextureEditor.prototype.constructor = TextureEditor;

		//	function TextureEditor(){
		//		var json = new THREE.Texture().toJSON();
		//		Object.setPrototypeOf( json, TextureEditor.prototype );
		//		return json;
		//	}
		//	TextureEditor.prototype = Object.create(Object.prototype);

			TextureEditor.prototype.exit = function(){

				var editor = this;

			};

			TextureEditor.prototype.copy = function( json ){
			//	param: texture json {object}

				var editor = this;

				var json = JSON.parse( JSON.stringify(json) ); // copy.

				for ( var key in json ) {
					switch ( key ){

						case "metadata":
						break;

						case "image":
							console.warn( "case:", key, "TODO!" );
						break;

					//	case "wrap":
						case "center":
						case "offset":
						case "repeat":
							var length = json[key].length;
							for ( var i=0; i < length; i++ ){
								editor[ key ][i] = json[ key ][i];
							}
						break;

						default:
							editor[ key ] = json[ key ];
						break;
					}
				}
				
			//	console.log( "json copied:", JSON.parse( JSON.stringify(editor) ) );
			};

			TextureEditor.prototype.reset = function(){

				var editor = this;
				console.log( "editor reset:" );

				var json = new THREE.Texture().toJSON();

				editor.copy( json );

			};

			TextureEditor.prototype.update = function( value ){

			//	value: {entitySelect.value: string, (texture.id) }
			//	dependences: textue_droplist (global), 
			//				 texture_entities (global).

				var editor = this;

			//	get new texture.
				var texture = (function getTextureByEntityId( value ){

					if ( !arguments.length ) 
						var id = parseInt( texture_droplist.value );
					else
						var id = parseInt( value );

					if ( id === NaN ) return; // important! // return undefined;

					return texture_entities.find( function( texture ){
						return texture.id === id;
					});

				})( value );

				if ( !texture ) {
					editor.reset(); // reset editor.
					console.log("editor updated:", false);
					return false; // important!
				}

			//	Working with json.
			//	create a texture json and update editor.
				var json = texture.toJSON();

				if ( !json ) {
					editor.reset(); // reset editor.
					console.log("editor updated:", false);
					return false; // important!
				}

				console.log( "editor update:", json );

			//	copy json (update).
				editor.copy( json );

			//	return true.
				console.log("editor updated:", true);
				return true; // important!

			};

		//	editor undo/redo.

			(function(){

				var interval;

				TextureEditor.prototype.undo = function( undo, redo ){

					var editor = this;

					if ( undo === undefined ) return;
					if ( redo === undefined ) return;

					if ( !undo.length ) return;

				//	Get undo json.
					var json = undo.shift();

					if ( !json ) return;

				//	Move json to redo.
					redo.unshift( json );

					clearTimeout( interval );
					interval = setTimeout( function(){

					//	Copy texture state (undo).
						editor.copy( json ); // update.
					//	Will watcher update texture?

						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );

					}, 250);

				};

				TextureEditor.prototype.redo = function( undo, redo ){

					var editor = this;

					if ( undo === undefined ) return;
					if ( redo === undefined ) return;

					if ( !redo.length ) return;

				//	Get redo json.
					var json = redo.shift();

					if ( !json ) return;

				//	Move json to undo.
					undo.unshift( json );

					clearTimeout( interval );
					interval = setTimeout( function(){

					//	Copy texture state (redo).
						editor.copy( json ); // update.
					//	Will watcher update texture?

						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );

					}, 250);
				};

			})();

		</script>

		<script>

			const textureEditor = ( function( editor ){

				const undo = [], redo = [];
				const RAD2DEG = THREE.Math.RAD2DEG;
				const DEG2RAD = THREE.Math.DEG2RAD;

			//	droplists.

				const map_droplist    = document.getElementById("material-map-droplist");
				const key_droplist    = document.getElementById("texture-key-droplist");
				const vector_droplist = document.getElementById("texture-vector-droplist");
				const entity_droplist = document.getElementById("texture-entities-droplist");

			//	mouse inputs.

				const increase_v = document.getElementById("texture-value-increase");
				const increase_x = document.getElementById("texture-vector-x-increase");
				const increase_y = document.getElementById("texture-vector-y-increase");

				const decrease_v = document.getElementById("texture-value-decrease");
				const decrease_x = document.getElementById("texture-vector-x-decrease");
				const decrease_y = document.getElementById("texture-vector-y-decrease");

			//	keyboard inputs.

				const vector_x    = document.getElementById("texture-vector-x-input");
				const vector_y    = document.getElementById("texture-vector-y-input");
				const text_input  = document.getElementById("texture-text-input");
				const value_input = document.getElementById("texture-value-input");

			//	texture tab buttons.

				const exit_button = document.getElementById("texture-exit-mode");
				const redo_button = document.getElementById("texture-redo-button");
				const undo_button = document.getElementById("texture-undo-button");
				const create_button = document.getElementById("create-texture-button");
				const replace_button = document.getElementById("replace-image-button");

			//	texture tab file inputs.

				const image_fileinput = document.getElementById("image-file-input");
				const texture_fileinput = document.getElementById("texture-file-input");

			//	texture tab state.

				const state = (function(){

					function TextureTabState(){

						var object = {
							"vector x": "",
							"vector y": "",
							"text input": "",
							"value input": "",
							"map droplist": "",
							"key droplist": "",
							"vector droplist": "",
							"entity droplist": "",
						};

						Object.setPrototypeOf( object, TextureTabState.prototype );

						return object;
					}

					TextureTabState.prototype = Object.create(Object.prototype);

					TextureTabState.prototype.update = function(){

						this["text input"] = text_input.value;
						this["map droplist"] = map_droplist.value;
						this["key droplist"] = key_droplist.value;
						this["entity droplist"] = entity_droplist.value;
						this["vector droplist"] = vector_droplist.value;

						switch ( key_droplist.value ){

						//	case "name":
						//	case "uuid":
						//		this["text input"] = text_input.value;
						//	break;

							case "flipY":
								this["value input"] = Boolean(value_input.value);
							break;

							case "rotation":
								this["value input"] = DEG2RAD * Number(value_input.value);
							break;

							default:
								this["value input"] = Number(value_input.value);
							break;
						}

						this["vector x"] = Number(vector_x.value);
						this["vector y"] = Number(vector_y.value);

					};

					return new TextureTabState();

				})();

			//	helpers.

				function getTextureByEntityId( value ){

					if ( arguments.length ) 
						var id = parseInt( value );
					else
						var id = parseInt( texture_droplist.value );

					if ( id === NaN ) return;

					return texture_entities.find( function( texture ){
						return texture.id === id;
					});
				}

				function getMaterialByEntityId( value ){

					if ( arguments.length ) 
						var id = parseInt( value );
					else
						var id = parseInt( material_droplist.value );

					if ( id === NaN ) return;

					return material_entities.find( function( material ){
						return material.id === id;
					});
				}

			//	add to undo/redo.

				function addtoUndo(){
					var json = JSON.parse( JSON.stringify(editor) );
					json && undo.unshift( json );
				}

				function clearUndoRedo(){
					undo.length = 0; 
					redo.length = 0;
					return;
				}

			//	exit from edit mode.

				function exitFromEditMode(){
					editor.reset();
				//	Reset droplists.
					key_droplist.value = "";
					vector_droplist.value = "";
					entity_droplist.value = "";
				//	Reset keyboard inputs.
				//	vector_x.value = ""; // infinity loop!
				//	vector_y.value = ""; // infinity loop!
				//	text_input.value = ""; // infinity loop!
				//	value_input.value = ""; // infinity loop!
				//	Reset redo/undo.
					setTimeout( clearUndoRedo );
				}

			//	switch to edit mode.

				function switchToEditMode( value ){
					if ( !editor.update( value ) ) 
						exitFromEditMode();
				//	Reset redo/undo.
					else setTimeout( clearUndoRedo );
				}

				undo_button.addEventListener( "click", function(){ 
					debugMode && console.log( "undo:", undo.length, "redo:", redo.length );

				//	clear undo/redo.
					if ( !state["entity droplist"] ) return clearUndoRedo();
					
				//	undo.
					else undo.length && editor.undo(undo, redo); // ends here.

				});

				redo_button.addEventListener( "click", function(){ 
					debugMode && console.log( "undo:", undo.length, "redo:", redo.length );

				//	clear undo/redo.
					if ( !state["entity droplist"] ) return clearUndoRedo();

				//	redo.
					else redo.length && editor.redo(undo, redo); // ends here.

				});

				(function(){

					var interval;

					exit_button.addEventListener( "click",  function(){
						clearTimeout( interval );
						interval = setTimeout( exitFromEditMode, 250);
					});

				})();

			//	droplists.

				(function(){

					function droplistBlur(){
						key_droplist.blur();
						vector_droplist.blur();
						entity_droplist.blur();
					};

					key_droplist.addEventListener( "change", droplistBlur );
					vector_droplist.addEventListener( "change", droplistBlur );
					entity_droplist.addEventListener( "change", droplistBlur );

				})();

			//	keyboard inputs.

				(function(){

				//	const vector_x    = document.getElementById("texture-vector-x-input");
				//	const vector_y    = document.getElementById("texture-vector-y-input");
				//	const text_input  = document.getElementById("texture-text-input");
				//	const value_input = document.getElementById("texture-value-input");

				//	keyInputs blur.

					function keyinputBlur(){ 
						vector_x.blur(); 
						vector_y.blur(); 
						text_input.blur(); 
						value_input.blur(); 
					}

					vector_x.addEventListener( "change", keyinputBlur );
					vector_y.addEventListener( "change", keyinputBlur );
					text_input.addEventListener( "change", keyinputBlur );
					value_input.addEventListener( "change", keyinputBlur );

				//	keyInputControls.

					function enableKeyInputControls(){
						keyInputControls.isDisabled = false;
					}

					function disableKeyInputControls(){
						keyInputControls.isDisabled = true;
					}

					vector_x.addEventListener( "blur", enableKeyInputControls );
					vector_y.addEventListener( "blur", enableKeyInputControls );
					text_input.addEventListener( "blur", enableKeyInputControls );
					value_input.addEventListener( "blur", enableKeyInputControls );

					vector_x.addEventListener( "focus", disableKeyInputControls );
					vector_y.addEventListener( "focus", disableKeyInputControls );
					text_input.addEventListener( "focus", disableKeyInputControls );
					value_input.addEventListener( "focus", disableKeyInputControls );


				})();

			//	mouse inputs.

				(function(){

					var interval;

				//	const key_droplist = document.getElementById("texture-key-droplist");
				//	const value_input = document.getElementById("texture-value-input");
				//	const increase_v = document.getElementById("texture-value-increase");
				//	const decrease_v = document.getElementById("texture-value-decrease");

					increase_v.addEventListener( "mousedown", onMouseDown );
					decrease_v.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
						clearTimeout( interval ); // important!
					//	debugMode && console.log( "on MouseUp:", interval );
					});

					increase_v.addEventListener( "click", onMouseClick );
					decrease_v.addEventListener( "click", onMouseClick );

					function onMouseDown(){ 

						clearTimeout( interval ); // important!

						if ( !state["entity droplist"] ) return;

					//	disabled on mouse down.
						if ( state["key droplist"] === "name" ) return;
						if ( state["key droplist"] === "uuid" ) return;
						if ( state["key droplist"] === "flipY" ) return;
						if ( state["key droplist"] === "format" ) return;
						if ( state["key droplist"] === "mapping" ) return;
						if ( state["key droplist"] === "minFilter" ) return;
						if ( state["key droplist"] === "magFilter" ) return;

						var button = this;
						var clock = new THREE.Clock();

					//	enabled on mouse down.
						interval = setTimeout( function onUpdate() {

						//	if ( isNaN(state["value input"]) ) return;

							var key = state["key droplist"];

							if ( key === "rotation" ) (function(){

								var step = 0.1 * Math.PI/180; // 0.1 deg.
								var max = Math.PI, min = -max;
								var value = Number(state["value input"]); // copy.

								if ( button === increase_v ) value = THREE.Math.clamp( value+step, min, max );
								if ( button === decrease_v ) value = THREE.Math.clamp( value-step, min, max );

								value_input.value = Number(RAD2DEG*value).toFixed(1); // string.

							})();

							else if ( key === "anisotropy" ) (function(){

								var step = 1/100, max = 1, min = -max;
								var value = Number(state["value input"]); // copy.

								if ( button === increase_v ) value = THREE.Math.clamp( value+step, min, max );
								if ( button === decrease_v ) value = THREE.Math.clamp( value-step, min, max );

								value_input.value = Number(value).toFixed(2); // string.

							})();

						//	update state.
							state.update(); // imporant!

							var dt = clock.getDelta();
							interval = setTimeout( onUpdate, dt );
						//	debugMode && console.log( "on Update:", interval );

						}, 500);
					}

					function onMouseClick(){

						clearTimeout( interval ); // important!
						if ( !state["entity droplist"] ) return;

						var button = this;

						var key = state["key droplist"];

					//	disabled on mouse click.

						if ( key === "name" ) return;

					//	enabled on mouse click.

						else if ( key === "uuid" ) (function(){ 
							text_input.value = THREE.Math.generateUUID(); 
							state.update(); // important!
						})();

						else if ( key === "flipY" ) (function(){ 
							value_input.value = !state["value input"]; // boolean.
						//	state.update(); // important!
						})();

						else if ( key === "format" ) (function(){

							var values = [
							//	order matters.
								THREE.AlphaFormat,THREE.RGBFormat,THREE.RGBAFormat,THREE.LuminanceFormat,
								THREE.LuminanceAlphaFormat, THREE.DepthFormat, THREE.DepthStencilFormat 
							]; 

							var step = 1, min = 0, max = values.length;
							var value = Number(state["value input"]); // copy.
							var index = values.findIndex(function( item ){ return item === value; });
							
							if ( button === increase_v ) value = values[ ( ++index % max + max ) % max ]; // mod();
							if ( button === decrease_v ) value = values[ ( --index % max + max ) % max ]; // mod();

							value_input.value = Number(value); // string.

						})();

						else if ( key === "mapping" ) (function(){

							var values = [
							//	order matters.
								THREE.UVMapping,THREE.CubeReflectionMapping,THREE.CubeRefractionMapping,
								THREE.EquirectangularReflectionMapping,THREE.EquirectangularRefractionMapping,
								THREE.SphericalReflectionMapping,THREE.CubeUVReflectionMapping,THREE.CubeUVRefractionMapping
							];

							var step = 1, min = 0, max = values.length;
							var value = Number(state["value input"]); // copy.
							var index = values.findIndex(function( item ){ return item === value; });
							
							if ( button === increase_v ) value = values[ ( ++index % max + max ) % max ]; // mod();
							if ( button === decrease_v ) value = values[ ( --index % max + max ) % max ]; // mod();

							value_input.value = Number(value); // string.

						})();

						else if ( key === "encoding" ) (function(){

							var values = [
							//	order matters.
								THREE.LinearEncoding,THREE.sRGBEncoding,THREE.GammaEncoding,
								THREE.RGBEEncoding,THREE.LogLuvEncoding,THREE.RGBM7Encoding,
								THREE.RGBM16Encoding,THREE.RGBDEncoding,THREE.BasicDepthPacking,
								THREE.RGBADepthPacking
							];

							var step = 1, min = 0, max = values.length;
							var value = Number(state["value input"]); // copy.
							var index = values.findIndex(function( item ){ return item === value; });
							
							if ( button === increase_v ) value = values[ ( ++index % max + max ) % max ]; // mod();
							if ( button === decrease_v ) value = values[ ( --index % max + max ) % max ]; // mod();

							value_input.value = Number(value); // string.

						})();

						else if ( key === "magFilter" ) (function(){

						//	order matters.
							var values = [ THREE.NearestFilter,THREE.LinearFilter ];

							var step = 1, min = 0, max = values.length;
							var value = Number(state["value input"]); // copy.
							var index = values.findIndex(function( item ){ return item === value; });
							
							if ( button === increase_v ) value = values[ ( ++index % max + max ) % max ]; // mod();
							if ( button === decrease_v ) value = values[ ( --index % max + max ) % max ]; // mod();

							value_input.value = Number(value); // string.

						})();

						else if ( key === "minFilter" ) (function(){

							var values = [ 
							//	order matters.
								THREE.NearestFilter,THREE.NearestMipMapNearestFilter,
								THREE.NearestMipMapLinearFilter,THREE.LinearFilter,
								THREE.LinearMipMapNearestFilter,THREE.LinearMipMapLinearFilter
							];

							var step = 1, min = 0, max = values.length;
							var value = Number(state["value input"]); // copy.
							var index = values.findIndex(function( item ){ return item === value; });
							
							if ( button === increase_v ) value = values[ ( ++index % max + max ) % max ]; // mod();
							if ( button === decrease_v ) value = values[ ( --index % max + max ) % max ]; // mod();

							value_input.value = Number(value); // string.

						})();

						else if ( key === "rotation" ) (function(){

							var step = 0.1 * Math.PI/180; // 0.1 deg.
							var max = Math.PI, min = -max;
							var value = Number(state["value input"]); // copy.

							if ( button === increase_v ) value = THREE.Math.clamp( value+step, min, max );
							if ( button === decrease_v ) value = THREE.Math.clamp( value-step, min, max );

							value_input.value = Number(RAD2DEG*value).toFixed(1); // string.

						})();

						else if ( key === "anisotropy" ) (function(){

							var step = 1/100, max = 1, min = -max;
							var value = Number(state["value input"]); // copy.

							if ( button === increase_v ) value = THREE.Math.clamp( value+step, min, max );
							if ( button === decrease_v ) value = THREE.Math.clamp( value-step, min, max );

							value_input.value = Number(value).toFixed(2); // string.

						})();


					//	update state.
						state.update(); // imporant!

						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
						debugMode && console.log( "on Mouse Click:", interval );
						debugMode && console.log( "state:", JSON.parse( JSON.stringify(state) ) ); 

					}

				})();

				(function(){

					var interval;

				//	const vector_x   = document.getElementById("texture-vector-x-input");
				//	const increase_x = document.getElementById("texture-vector-x-increase");
				//	const decrease_x = document.getElementById("texture-vector-x-decrease");

				//	const vector_y   = document.getElementById("texture-vector-y-input");
				//	const increase_y = document.getElementById("texture-vector-y-increase");
				//	const decrease_y = document.getElementById("texture-vector-y-decrease");

					increase_x.addEventListener( "mousedown", onMouseDown );
					decrease_x.addEventListener( "mousedown", onMouseDown );
					increase_y.addEventListener( "mousedown", onMouseDown );
					decrease_y.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
						clearTimeout( interval ); // important!
					//	debugMode && console.log( "on MouseUp:", interval );
					});

					increase_x.addEventListener( "click", onMouseClick );
					decrease_x.addEventListener( "click", onMouseClick );
					increase_y.addEventListener( "click", onMouseClick );
					decrease_y.addEventListener( "click", onMouseClick );

					function onMouseDown(){ 

						clearTimeout( interval ); // important!

						if ( !state["entity droplist"] ) return;

					//	disabled on mouse down.
						if ( state["vector droplist"] === "wrap" ) return;

						var button = this;
						var clock = new THREE.Clock();

					//	enabled on mouse down.
						interval = setTimeout( function onUpdate() {

							var key = state["vector droplist"];

							if ( key ) (function(){

								var step = 1/100, max = 1000, min = -max;

								if ( button === increase_x || button === decrease_x ) {
									var value = Number(state["vector x"]); // copy.

									if ( button === increase_x ) value = THREE.Math.clamp( value+step, min, max );
									if ( button === decrease_x ) value = THREE.Math.clamp( value-step, min, max );

									vector_x.value = Number(value).toFixed(2); // string.
								}
								
								else if ( button === increase_y || button === decrease_y ) {
									var value = Number(state["vector y"]); // copy.

									if ( button === increase_y ) value = THREE.Math.clamp( value+step, min, max );
									if ( button === decrease_y ) value = THREE.Math.clamp( value-step, min, max );

									vector_y.value = Number(value).toFixed(2); // string.
								}

							})();

						//	update state.
							state.update(); // imporant!

							var dt = clock.getDelta();
							interval = setTimeout( onUpdate, dt );
						//	debugMode && console.log( "on Update:", interval );

						}, 500);
					}

					function onMouseClick(){

						clearTimeout( interval ); // important!
						if ( !state["entity droplist"] ) return;

						var button = this;

						var key = state["vector droplist"];

					//	enabled on mouse click.

						if ( key === "wrap" ) (function(){

						//	order matters.
							var values = [ 
								THREE.RepeatWrapping,
								THREE.ClampToEdgeWrapping,
								THREE.MirroredRepeatWrapping
							];

							var step = 1, min = 0, max = values.length;
							var value = Number(state["vector x"]); // copy.
							var index = values.findIndex(function( item ){ return item === value; });

							if ( button === increase_x || button === increase_y ) 
								value = values[ ( ++index % max + max ) % max ]; // mod();
							if ( button === decrease_x ||  button === decrease_y ) 
								value = values[ ( --index % max + max ) % max ]; // mod();

							vector_x.value = vector_y.value = Number(value); // string.

						})();

						else if ( key ) (function(){

							var step = 1/100, max = 1000, min = -max;

							if ( button === increase_x || button === decrease_x ) {
								var value = Number(state["vector x"]); // copy.

								if ( button === increase_x ) value = THREE.Math.clamp( value+step, min, max );
								if ( button === decrease_x ) value = THREE.Math.clamp( value-step, min, max );

								vector_x.value = Number(value).toFixed(2); // string.
							}

							else if ( button === increase_y || button === decrease_y ) {
								var value = Number(state["vector y"]); // copy.

								if ( button === increase_y ) value = THREE.Math.clamp( value+step, min, max );
								if ( button === decrease_y ) value = THREE.Math.clamp( value-step, min, max );

								vector_y.value = Number(value).toFixed(2); // string.
							}

						})();

					//	update state.
						state.update(); // imporant!

						debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
						debugMode && console.log( "on Mouse Click:", interval );
						debugMode && console.log( "state:", JSON.parse( JSON.stringify(state) ) ); 

					}

				})();

			//	state watcher.

				(function(){

					var interval;

					watch( state, function( name, action, value, oldValue ){

						clearTimeout( interval );

					//	debugMode && console.log( "watch state:", { 
					//		"name":name, "action":action, "value":value 
					//	});

						switch ( name ){

						//	Consider arrays as single value.  important!
						//	Watcher ignores in-array changes. important!

							case "vector x":
							case "vector y":
								(function(){
									
								//	get droplist value.
									var key = state["vector droplist"];
									var entity_id = state["entity droplist"];

									var x = Number(state["vector x"]); // copy.
									var y = Number(state["vector y"]); // copy.

									if ( !entity_id ) x = y = "";               // reset.
									else if ( isNaN(x) || isNaN(y) ) {
										if ( key === "wrap" ) x = y = 1001;     // reset.
										else if ( key === "repeat" ) x = y = 1; // reset.
										else x = y = 0;                         // reset.
									} else if ( key === "wrap" ) {
										var wrapModes = [1000, 1001, 1002];
										if ( wrapModes.includes(x) && !wrapModes.includes(y) ) y = x;
										else if ( !wrapModes.includes(x) &&  wrapModes.includes(y) ) x = y;
										else if ( !wrapModes.includes(x) && !wrapModes.includes(y) ) x = y = 1001; // reset.
									}

								//	update editor.
									editor[ key ] = [ x, y ];

								//	display values.
									if ( key === "wrap"
									|| typeof x !== "number" 
									|| typeof y !== "number" ) {
										vector_x.value = x; // string.
										vector_y.value = y; // string.
									} else {
										vector_x.value = x.toFixed(2); // string.
										vector_y.value = y.toFixed(2); // string.
									} 

								})();

							break;

							case "text input":
								(function( value ){

								//	get droplist value.
									var key = state["key droplist"];
									var entity_id = state["entity droplist"];

								//	reset input value.
									if ( !entity_id ) text_input.value = ""; // reset!
								//	update editor name.
									else if ( key === "name" ) editor.name = value;
								//	display editor uuid.
									else if ( key === "uuid" ) editor.uuid = value;
								//	reset input value.
									else text_input.value = ""; // reset!

								})( value );

							break;

							case "value input":
								(function( value ){

								//	get droplist value.
									var key = state["key droplist"];
									var entity_id = state["entity droplist"];

								//	reset input value.
									if ( !entity_id ) value_input.value = ""; // reset!
									else if ( key === "name" ) value_input.value = ""; // reset!
									else if ( key === "uuid" ) value_input.value = ""; // reset!

									else if ( typeof value === "boolean" ) editor[ key ] = value;

								//	reset editor value.
									else if ( isNaN(value) || typeof value !== "number" ) {
										if ( key === "format" ) editor[ key ] = 1023;         // reset.
										else if ( key === "mapping" ) editor[ key ] = 300;    // reset.
										else if ( key === "rotation" ) editor[ key ] = 0;     // reset.
										else if ( key === "encoding" ) editor[ key ] = 3000;  // reset.
										else if ( key === "magFilter" ) editor[ key ] = 1006; // reset.
										else if ( key === "minFilter" ) editor[ key ] = 1008; // reset.
										else if ( key === "anisotropy" ) editor[ key ] = 1;   // reset.
										value_input.value = Number(editor[ key ]); // string.
									}
										
								//	update editor value.
									else if ( key ) editor[ key ] = Number(value);

								//	reset input value.
									else value_input.value = "";

								})( value );

							break;

							case "map droplist":
								(function( key ){

								//	get material.
									var material = getMaterialByEntityId();

								//	reset editor.
									if ( !material )
										return editor.reset();
									if ( !material[ key ] )
										return editor.reset();

								//	get texture id.
									var id = material[ key ].id;
								//	update droplist.
									entity_droplist.value = id.toString();
								//	update editor.
									editor.update( id );

								})( value );

							break;

							case "key droplist": 
								(function( key ){

								//	reset inputs.
								//	text_input.value = value_input.value = "";

									var entity_id = state["entity droplist"];

								//	reset inputs.
									if ( !entity_id )
										text_input.value = value_input.value = "";

								//	display values.
									else if ( key === "name" ) {
										value_input.value = "";
										text_input.value = editor[ key ]; // string.
									} 

									else if ( key === "uuid" ) {
										value_input.value = "";
										text_input.value = editor[ key ]; // string.
									} 

									else if ( key === "flipY" ) {
										text_input.value = "";
										value_input.value = Boolean(editor[ key ]); // string.
									} 

									else if ( key === "rotation" ) {
										text_input.value = "";
										value_input.value = Number(RAD2DEG*editor[key]).toFixed(1); // string!
									} 

									else if ( key === "anisotropy" ) {
										text_input.value = "";
										value_input.value = Number(editor[key]).toFixed(2); // string!
									} 

									else if ( key ) {
										text_input.value = "";
										value_input.value = editor[ key ];
									}

								//	reset inputs.
									else text_input.value = value_input.value = "";

								})( value );

							break;

							case "vector droplist": 
								(function( key ){

								//	reset inputs.
								//	vector_x.value = vector_y.value = "";

									var entity_id = state["entity droplist"];

								//	reset inputs.
									if ( !entity_id ) vector_x.value = vector_y.value = ""; // reset.

								//	display values.
									else if ( key && editor[ key ] && Array.isArray(editor[key]) ) { 
										if ( key === "wrap" ) {
											vector_x.value = Number(editor[ key ][0]).toFixed(0); // string!
											vector_y.value = Number(editor[ key ][1]).toFixed(0); // string!
										} else {
											vector_x.value = Number(editor[ key ][0]).toFixed(2); // string!
											vector_y.value = Number(editor[ key ][1]).toFixed(2); // string!
										}
									} 

								//	reset inputs.
									else vector_x.value = vector_y.value = "";

								})( value );

							break;

							case "entity droplist":
								(function( id ){

								//	reset state key and vector droplists.
								//	will recall watcher on state.update().
									state["key droplist"] = "";    // important!
									state["vector droplist"] = ""; // important!

								//	reset editor/droplists.
									if ( isNaN( parseInt(id) ) ) {
									//	reset editor.
										editor.reset();
									//	reset droplists.
										key_droplist.value = "";
										vector_droplist.value = "";
									//	reset redo/undo.
										undo.length = 0; redo.length = 0;

									} else {
									//	update editor.
										editor.update( id );
									//	reset droplists.
									//	key_droplist.value = ""; // infinity loop!
									//	vector_droplist.value = ""; // infinity loop!
									//	reset redo/undo.
										undo.length = 0; redo.length = 0;

									}


								})( value );

							break;

						}

						state.update(); // important!

						interval = setTimeout( function(){
							debugMode && console.log( "state:", JSON.parse( JSON.stringify(state) ) ); 
						}, 100);

					});

				})();

			//	editor watcher.

				(function(){

					var interval;

					watch( editor, function( key, action, value, oldValue ){
						var value = JSON.parse( JSON.stringify(value) ); // cleanup copy. 

						clearTimeout( interval );

						debugMode && console.log( "watch editor:", { 
							"key":key, "action":action, "value":value 
						});

					//	get texture.
						var id = state["entity droplist"]; // string.
						var texture = texture_entities.getTextureById( id );
						if ( texture === undefined ) return;

						if ( texture && key && action === "set" ) {

						//	update texture values.
							switch ( key ) {

								case "image":
								case "images":
									console.warn( "case", key+":", "TODO!" );
								break;

							//	wrap, special case, always triggers!

								case "wrap":

									(function( key, value ){
							
										if ( isNaN(editor.wrap[0]) || isNaN(editor.wrap[1]) ) { 
											texture.wrapS = texture.wrapT = 1001; // reset.
										} else {
											texture.wrapS = Number( editor.wrap[0] ); // copy.
											texture.wrapT = Number( editor.wrap[1] ); // copy.
										}

									})( key, value );

								break;

							//	vector2.
							
								case "center":
								case "offset":
								case "repeat":

									(function( key, value ){

										if ( isNaN(editor[key][0]) || isNaN(editor[key][1]) ) { 
											if ( key === "repeat" ) 
												texture[ key ].x = texture[ key ].y = 1; // reset.
											else 
												texture[ key ].x = texture[ key ].y = 0; // reset.
										} else {
											texture[ key ].x = Number( editor[key][0] ); // copy.
											texture[ key ].y = Number( editor[key][1] ); // copy.
										}

									})( key, value );

								break;

							//	string.

							//	case "uuid":
								case "name":

									(function( key, value ){
										if ( typeof editor[ key ] === "string" )
											texture[ key ] = editor[ key ].toString(); // string.
									})( key, value );

								break;

							//	boolean.

								case "flipY":

									(function( key, value ){
										if ( typeof editor[ key ] === "boolean" )
											texture[ key ] = Boolean(editor[ key ]); // boolean.
									})( key, value );

								break;

							//	number.

								case "format":
								case "mapping":
								case "rotation":
								case "encoding":
								case "magFilter":
								case "minFilter":
								case "anisotropy":

									(function( key, value ){

										if ( isNaN(editor[key]) || typeof editor[key] !== "number" ) {
										//	reset.
											if ( key === "format" ) texture[ key ] = 1023;         // reset.
											else if ( key === "mapping" ) texture[ key ] = 300;    // reset.
											else if ( key === "rotation" ) texture[ key ] = 0;     // reset.
											else if ( key === "encoding" ) texture[ key ] = 3000;  // reset.
											else if ( key === "magFilter" ) texture[ key ] = 1006; // reset.
											else if ( key === "minFilter" ) texture[ key ] = 1008; // reset.
											else if ( key === "anisotropy" ) texture[ key ] = 1;   // reset.

										} else texture[ key ] = Number( editor[key] ); // number.

									})( key, value );

								break;

							}
						}

						interval = setTimeout( function( key ){
							debugMode && console.log( "texture:", texture );
 
						//	texture needsUpdate.
							if ( texture ) texture.needsUpdate = true; // important!

						//	addtoUndo/redo.

							if ( texture && key && action === "set" ) {
								switch ( key ){

									case "wrap":
								//	DONT USE "wrap"; watcher calls "wrap" always and last.
									break;

									case "name":
									case "center":
									case "offset":
									case "repeat":
									case "format":
									case "mapping":
									case "rotation":
									case "magFilter":
									case "minFilter":
									case "anisotropy":
										addtoUndo();
									break;
								}
							}

							debugMode && console.log( "undo:", undo.length, "redo:", redo.length );
						//	debugMode && console.log( "state:", JSON.parse( JSON.stringify(state) ) ); 
						//	debugMode && console.log( "editor:", JSON.parse( JSON.stringify(editor) ) ); 

						//	display undo/redo values.
							setTimeout( function( key ){

							//	if ( !texture ) return;
								if ( !state["entity droplist"] ) return;

							//	key droplist.

								key && texture && state["key droplist"] && (function( key ){

									text_input.value = value_input.value = ""; // reset;

									switch ( key ){
										case "uuid":
										case "name":
											text_input.value = texture[ key ]; // string.
										break;
										case "flipY":
											value_input.value = Boolean(texture.flipY); // string.
										break;
										case "anisotropy":
											value_input.value = texture.anisotropy.toFixed(2); // string.
										break;
										case "rotation":
											value_input.value = Number(RAD2DEG*texture.rotation).toFixed(1); // string.
										break;
										default:
											value_input.value = texture[ key ];
										break;
									}

								})( state["key droplist"] );

							//	vector droplist.

								key && texture && state["vector droplist"] && (function( key ){

								//	vector_x.value = vector_y.value = ""; // reset;

									switch ( key ){
										case "wrap":
											vector_x.value = texture.wrapS.toFixed(0); // string.
											vector_y.value = texture.wrapT.toFixed(0); // string.
										break;
										default:
											vector_x.value = texture[key].x.toFixed(2); // string.
											vector_y.value = texture[key].y.toFixed(2); // string.
										break;
									}

								})( state["vector droplist"] );

								return;

							}, 100, key);

							return;

						}, 100, key);

					});

				})();

				//	if ( texture && key && action === "set" ) {
				//		if ( key === "name" ) addtoUndo();
				//		if ( key === "center" ) addtoUndo();
				//		if ( key === "offset" ) addtoUndo();
				//		if ( key === "repeat" ) addtoUndo();
				//		if ( key === "format" ) addtoUndo();
				//		if ( key === "mapping" ) addtoUndo();
				//		if ( key === "rotation" ) addtoUndo();
				//		if ( key === "magFilter" ) addtoUndo();
				//		if ( key === "minFilter" ) addtoUndo();
				//		if ( key === "anisotropy" ) addtoUndo();
				//	//	DONT USE "wrap"; watcher calls "wrap" always and last.
				//	//	if ( key === "wrap" ) addtoUndo(); // DONT USE "wrap"; 
				//	}

			//	state eventListeners.

				(function(){
					
					function onStateUpdate(){ 
						state.update();  // imporant!
					//	debugMode && console.log( "state:", JSON.parse( JSON.stringify(state) ) ); 
					}

					increase_v.addEventListener( "click", onStateUpdate );
					increase_x.addEventListener( "click", onStateUpdate );
					increase_y.addEventListener( "click", onStateUpdate );
					decrease_v.addEventListener( "click", onStateUpdate );
					decrease_x.addEventListener( "click", onStateUpdate );
					decrease_y.addEventListener( "click", onStateUpdate );
					exit_button.addEventListener( "click", onStateUpdate );
					redo_button.addEventListener( "click", onStateUpdate );
					undo_button.addEventListener( "click", onStateUpdate );
					create_button.addEventListener( "click", onStateUpdate );
					replace_button.addEventListener( "click", onStateUpdate );

					vector_x.addEventListener( "change", onStateUpdate );
					vector_y.addEventListener( "change", onStateUpdate );
					text_input.addEventListener( "change", onStateUpdate );
					value_input.addEventListener( "change", onStateUpdate );
					map_droplist.addEventListener( "change", onStateUpdate );
					key_droplist.addEventListener( "change", onStateUpdate );
					vector_droplist.addEventListener( "change", onStateUpdate );
					entity_droplist.addEventListener( "change", onStateUpdate );
					image_fileinput.addEventListener( "change", onStateUpdate );
					texture_fileinput.addEventListener( "change", onStateUpdate );

				})();

			//	Init.

				(function(){
					editor.reset(); // important!
					state.update(); // important!
				})();

				return editor;  // important!

			})( new TextureEditor() );


		</script>

		<script>
/*
		//	Texture Editor.

		//	Create a texture json to hold editor data.
			const textureEditor = ( function( editor ){

				const images = {};
				const undo = [], redo = [];

			//	Material tab.

				const textureMap = { value:"" };

				(function( selector ){
					TabUI.Material.tab.querySelector(selector)
					.addEventListener("change", function(){
						textureMap.value = this.value;  // string.
					});
				})("select#material-map-droplist");

			//	droplists.

				const keySelect    = {value:""}; // string.
				const entitySelect = {value:""}; // string.
				const vectorSelect = {value:""}; // string.

				const keys_droplist   = document.getElementById("texture-keys-droplist");
				const entity_droplist = document.getElementById("texture-entities-droplist");
				const vector_droplist = document.getElementById("texture-vector-droplist");

			//	inputs.

				const text_input  = document.getElementById("texture-text-input");
				const value_input = document.getElementById("texture-value-input");
				const vector_x_input = document.getElementById("texture-vector-x-input");
				const vector_y_input = document.getElementById("texture-vector-y-input");

			//	input buttons.

				const value_increase_button = document.getElementById("texture-value-increase");
				const value_decrease_button = document.getElementById("texture-value-decrease");
				const vector_x_increase_button = document.getElementById("texture-vector-x-increase");
				const vector_x_decrease_button = document.getElementById("texture-vector-x-decrease");
				const vector_y_increase_button = document.getElementById("texture-vector-y-increase");
				const vector_y_decrease_button = document.getElementById("texture-vector-y-decrease");

			//	helpers.

				function getMaterialByEntityId( value ){

					if ( !arguments.length ) 
						var id = parseInt( material_droplist.value );
					else
						var id = parseInt( value );

					var id = parseInt( material_droplist.value );
					if ( id === NaN ) return undefined;
					return material_entities.find( function( material ){
						return material.id === id;
					});
				}
				
				function getTextureByEntityId( value ){

					if ( !arguments.length ) 
						var id = parseInt( texture_droplist.value );
					else
						var id = parseInt( value );

					if ( id === NaN ) return undefined;
					return texture_entities.find( function( texture ){
						return texture.id === id;
					});
				}

			//	reset select droplist values.

				function resetEntitySelectValue(){
					entitySelect.value = entity_droplist.value = "";
					entity_droplist.dispatchEvent( new Event("change") );
				}

			//	update select droplist values.

				function updateEntitySelectValue( value ){ 
					if ( value === undefined ) {
						entitySelect.value = entity_droplist.value; 
					} else {
						entitySelect.value = entity_droplist.value = value;
						entity_droplist.dispatchEvent( new Event("change") );
					}
				}

			// 	editor undo/redo.

				(function(){

					var interval;

				//	editor.undo = function(){
				//		//	addtoUndo();
				//	};

				//	editor.redo = function(){
				//		//	addtoRedo();
				//	};

				})();

			//	droplists.

				(function(){

					function blur_droplists(){
						keys_droplist.blur();
						vector_droplist.blur();
						entity_droplist.blur();
					};
					
					function reset_inputs(){
						text_input.value = "";
						value_input.value = "";
						vector_x_input.value = "";
						vector_y_input.value = "";
					}
					
					function reset_selects(){

						keySelect.value = keys_droplist.value = "";
						vectorSelect.value = vector_droplist.value = "";

					}

				//	const keys_droplist   = document.getElementById("texture-keys-droplist");
				//	const entity_droplist = document.getElementById("texture-entities-droplist");
				//	const vector_droplist = document.getElementById("texture-vector-droplist");

					entity_droplist.addEventListener( "change", function(){

						blur_droplists();

						entitySelect.value = entity_droplist.value; // updates editor.

						reset_selects(); // reset selects.
					
						reset_inputs(); // reset input fields.
					});

					keys_droplist.addEventListener( "change", function(){

						blur_droplists();

						keySelect.value = keys_droplist.value; // updates editor.


					});

					vector_droplist.addEventListener( "change", function(){

						blur_droplists();

						vectorSelect.value = vector_droplist.value; // updates editor.

					});

				})();

			//	key inputs.

				(function(){

					var interval;

					const vector_x = document.getElementById("texture-vector-x-input");
					const vector_y = document.getElementById("texture-vector-y-input");
					const text_input  = document.getElementById("texture-text-input");
					const value_input = document.getElementById("texture-value-input");

				})();


			//	mouse inputs.

				(function(){

					var interval;

					const increase_v = document.getElementById("texture-value-increase");
					const decrease_v = document.getElementById("texture-value-decrease");

					const increase_x = document.getElementById("texture-vector-x-increase");
					const increase_y = document.getElementById("texture-vector-y-increase");
					const decrease_x = document.getElementById("texture-vector-x-decrease");
					const decrease_y = document.getElementById("texture-vector-y-decrease");


				})();


			//	buttons.

				(function(){

					var interval;

					const exit_button = document.getElementById("texture-exit-mode");
					const undo_button = document.getElementById("texture-undo-button");
					const redo_button = document.getElementById("texture-redo-button");

					undo_button.addEventListener( "click", editor.undo );
					redo_button.addEventListener( "click", editor.redo );
					exit_button.addEventListener( "click", function(){
						clearTimeout(interval);
						interval = setTimeout( resetEntitySelectValue, 250 );
					});


				})();

			//	file inputs.

				(function(){

					const image_fileinput = document.getElementById("image-file-input");
					const texture_fileinput = document.getElementById("texture-file-input");

				})();

			//	watchers.

				(function(){

				//	const keySelect    = {value:""}; // string.
				//	const textureMap   = {value:""}; // string.
				//	const entitySelect = {value:""}; // string.
				//	const vectorSelect = {value:""}; // string.
					
					function reset(){
						keySelect.value = keys_droplist.value = "";
						entitySelect.value = entity_droplist.value = ""
						vectorSelect.value = vector_droplist.value = "";
						text_input.value = value_input.value = "";
						vector_x_input.value = vector_y_input.value = "";
					}

					watch(editor, function( key, action, newValue, oldValue ){
						debugMode && console.log( "entitySelect watch:", key,
						action, "newValue:", newValue, "oldValue:", oldValue  );
					});

					watch(entitySelect, function( key, action, newValue, oldValue ){
						debugMode && console.log( "entitySelect watch:", key, 
						action, "newValue:", newValue, "oldValue:", oldValue  );

						if ( !newValue ) return reset();
						
						var texture = getTextureByEntityId( newValue );
						if ( !texture ) return reset();

					//	update editor.
						"metadata,uuid,name,mapping,repeat,offset,center,rotation,wrap,format,minFilter,magFilter,anisotropy,flipY,undo"

					//	Update vectors direct from editor.
						displayVectorValues( keySelect.value );
						displayVectorValues( vectorSelect.value );

					});



				//	reset input values.

					function resetKeyInputValues(){
						text_input.value = "";
						value_input.value = "";
					}

					function resetVectorInputValues(){
						vector_x_input.value = "";
						vector_y_input.value = "";
					}

				//	update input values.

					function updateKeyInputValues( key ){
						if ( editor[ key ] === undefined ) return resetKeyInputValues();
						value_input.value = editor[ key ];
					}

					function updateVectorInputValues( key ){
						if ( editor[ key ] === undefined ) return resetVectorInputValues();
						vector_x_input.value = parseFloat( editor[ key ].x ).toFixed(2);
						vector_y_input.value = parseFloat( editor[ key ].y ).toFixed(2);
					}

				//	display vector values.

					function displayVectorValues( key ){

						switch ( key ){
							case "offset":
							case "repeat":
							case "center":
								updateVectorInputValues( key );
							break;

							case "wrapS":
								editor.wrap[0] = value;
							break;

							case "wrapT":
								editor.wrap[1] = value;
							break;

							default:
								updateKeyInputValues( key );
							break;
						}

					}

				//	reset select droplist values.

					function resetKeySelectValue(){
						keySelect.value = keys_droplist.value = "";
						keys_droplist.dispatchEvent( new Event("change") );
					}

					function resetVectorSelectValue(){
						vectorSelect.value = vector_droplist.value = "";
						vector_droplist.dispatchEvent( new Event("change") );
					}

				//	update select droplist values.

					function updateKeySelectValue( value ){ 
						if ( value === undefined ) {
							keySelect.value = keys_droplist.value; 
						} else {
							keySelect.value = keys_droplist.value = value;
							keys_droplist.dispatchEvent( new Event("change") );
						}
					}

					function updateVectorSelectValue( value ){
						if ( value === undefined ) {
							vectorSelect.value = vector_droplist.value; 
						} else {
							vectorSelect.value = vector_droplist.value = value;
							vector_droplist.dispatchEvent( new Event("change") );
						}
					}

				//	exit from edit mode.

					function exitFromEditMode(){
						editor.reset(); // important!
						resetEntitySelectValue();
						resetKeySelectValue();
						resetKeyInputValues();
						resetVectorSelectValue();
						debugMode && console.log( arguments.callee.name, editor );
						return;
					}

				//	switch to edit mode.

					function switchToEditMode( value ){
						if ( !editor.update( value ) ) exitFromEditMode();
					}

					function updateTextureMapValue( value ){}

					function updateVectorInputValues( value ){}


				//	Update texture entity droplist when material texture map selected.
					watch(textureMap, function( key, action, newValue, oldValue ){
						debugMode && console.log( "textureMap watch:", key,  
						action, "newValue:", newValue, "oldValue:", oldValue );

						if ( !newValue ) return resetEntitySelectValue();
						
					//	Get material.
						var material = getMaterialByEntityId();
						if ( !material || !material[ newValue ] ) return resetEntitySelectValue();
					//	Get texture.
						var texture = material[ newValue ];
						if ( !texture || !texture.isTexture ) return resetEntitySelectValue();
					//	Update droplist.
						updateEntitySelectValue( texture.id.toString() ); // string.

					});

				//	Update texture tab editor.

					watch(entitySelect, function( key, action, newValue, oldValue ){
						debugMode && console.log( "entitySelect watch:", key, 
						action, "newValue:", newValue, "oldValue:", oldValue  );

						switchToEditMode( newValue ); // important!

					//	Display vectors direct from editor.
						updateEntitySelectValue();
						updateKeySelectValue();
						updateVectorSelectValue();

					//	Update vectors direct from editor.
						displayVectorValues( keySelect.value );
						displayVectorValues( vectorSelect.value );

					});
				})();


				return editor;

			})( new THREE.Texture().toJSON() );
*/

		</script>

		<script>

			localPlayer.controller.movementSpeed = 10;

		//	Entities.

		//	debugMode && (function(){
		//		var r = 1;
		//		var geometry = new THREE.BoxGeometry(r,r,r);
		//		var material = new THREE.MeshLambertMaterial();
		//		var cube = new THREE.Mesh(geometry, material);
		//		cube.name = "local player cube";
		//		var geometry = new THREE.SphereGeometry(0.7,8,12);
		//		var material = new THREE.MeshLambertMaterial();
		//		var sphere = new THREE.Mesh(geometry, material);
		//		sphere.name = "local player sphere";
		//	//	cube.add( sphere );
		//		localPlayer.add( cube );
		//	})();

		//	box coluctions.

			debugMode && (function(){

				var material = new THREE.MeshStandardMaterial({name:"mtl00"});
				var maps = "map,aoMap,envMap,lightMap,bumpMap,alphaMap,normalMap,specularMap,";
				maps += "gradientMap,emissiveMap,metalnessMap,roughnessMap,displacementMap";
				material.envMap = new THREE.CubeTexture();
				maps.split(",").forEach( function( key ){
					if ( key !== "envMap" ) material[ key ] = new THREE.Texture();
				}); debugMode && console.log( material );
				material_entities.add( material );
			})();

		//	box coluctions.

			debugMode && (function(){

				(function(){
					var w = 10; var h = 5;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					octree.importThreeMesh( new THREE.Mesh(box) );
					var geometry = new THREE.EdgesGeometry( box );
					var material = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 1";
					scene.add( segments );
				})();

				(function(){
					var w = 10, h = 20;
					var x = 10, y = h/2, z = -4;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 1";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 2";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

				(function(){
					var w = 12, h = 10;
					var x = 15, y = h/2, z = -11;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 2";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 3";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

				(function(){
					var w = 8, h = 10;
					var x = -9, y = h/2, z = 5;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 3";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 4";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

				(function(){
					var w = 12, h = 20, d = 2;
					var x = -14, y = h/2, z = 10;
					var box = new THREE.BoxGeometry(w,h,d);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 4";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 5";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

				(function(){
					var w = 4, h = 20, d = 20;
					var x = -17, y = h/2, z = 12;
					var box = new THREE.BoxGeometry(w,h,d);
					box.translate(0, h/2, 0);
					var material = new THREE.MeshLambertMaterial();
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "building 5";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 6";
					segments.position.copy( mesh.position );
					scene.add( mesh );
					cameraControls.rigidObjects.push( mesh );
				})();

			//	var groupA = new THREE.Object3D();
			//	var groupB = new THREE.Object3D();

			//	groupA.add( scene.getObjectByName("building 1").clone() );
			//	groupA.add( scene.getObjectByName("building 2").clone() );
			//	groupB.add( scene.getObjectByName("building 3").clone() );
			//	groupB.add( scene.getObjectByName("building 4").clone() );
			//	groupB.add( scene.getObjectByName("building 5").clone() );

			})();

		</script>

		<script>

		//	Add entities.

		//	Add Object3D entities.
			scene.traverse(function( object ){
				entities.add( object );
			});

		//	Add Material entities.
			entities.forEach( function( entity ){

			//	It looks in "entities" manager only.
			//	It looks the root Object3D, but not children.

				var object = scene.getObjectById( entity.id );
				if ( !object || !object.material ) return; // important!

				if ( Array.isArray( object.material ) )
					object.material.forEach( addtoManager );
				else 
					addtoManager( object.material );

				function addtoManager( material ){
					rename( material );
					addEntity( material );
				}

				function rename( material ){
					if ( material.name ) return;
					material.name = "mtl"+material.id;;
				}

				function addEntity( material ){
					var included = material_entities.includes( material );
					debugMode && console.log( "included:", included );
					if ( !included ) material_entities.add( material );
				}
			});

		//	Add Texture entities.
			material_entities.forEach( function( material ){
				for ( var name in material ) (function( key ){
					material[key] && material[key].isTexture 
					&& texture_entities.add( material[ key ] );
				})( name );
			});

			console.log( {"object3DEditor": object3DEditor} ); // debug!
			console.log( {"materialEditor": materialEditor} ); // debug!
			console.log( {"textureEditor" : textureEditor}  ); // debug!

		</script>

		<script src="/ecs/engine/editor/ViewportTab.js"></script>

	</body>
</html>
