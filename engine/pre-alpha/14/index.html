<!DOCTYPE html>
<html lang="en">
	<head>

		<title>Legacy ECS Engine (pre-alpha 0.14)</title>

		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">
		<link rel="stylesheet" href="/css/jcrop.css">

		<script src="/js/watch.js"></script>
		<script src="/js/Objectid.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>
		<script src="/js/jcrop.js"></script>

		<style>

			body {
				margin: 0px;
				font-size: 13px;
				font-family: sans-serif;
				background-repeat: repeat;
				background-image: url("https://i.imgur.com/rnZZU0i.png") !important;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-matcap,
			.btn-terrain {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}

			.btn-matcap + .btn-matcap,
			.btn-terrain + .btn-terrain {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/ecs/js/three.js"></script>
		<script src="/ecs/js/TabUI.js"></script>
		<script src="/ecs/js/MeshWalk.js"></script>
		<script src="/ecs/js/UVsDebug.js"></script>
		<script src="/ecs/js/FBXLoader.js"></script>
		<script src="/ecs/js/VirtualInput.js"></script>
		<script src="/ecs/js/KeyboardState.js"></script>
		<script src="/ecs/js/EditorControls.js"></script>
		<script src="/ecs/js/SubdivisionModifier.js"></script>
		<script src="/ecs/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

		<script>

		//	TabUI.

			(function(){

				var sidePanel = createSidePanel();
				document.body.appendChild( sidePanel );

				var loginTab = TabUI.add( "Login", "login-tab" );
				var debugTab = TabUI.add( "Debug", "debug-tab" );
				var levelTab = TabUI.add( "Levels", "level-tab" );
				var editorTab = TabUI.add( "Editor", "editor-tab" );
				var cameraTab = TabUI.add( "Camera", "camera-tab" );
				var controlTab = TabUI.add( "Controls", "control-tab" );
				var playersTab = TabUI.add( "Players", "players-tab" );
				var materialTab = TabUI.add( "Materials", "material-tab" );
				var animationTab = TabUI.add( "Animations", "animation-tab" );

				TabUI.append("Editor", "Controls", "Camera", "Players", "Animations", "Materials", "Levels", "Debug" );
				TabUI.Editor.role.classList.add("active");
				TabUI.Editor.tab.classList.add("in","active");

			})();

		</script>

		<script src="/ecs/engine/Enviroment.js"></script>
		<script src="/ecs/engine/core/entity.js"></script>
		<script src="/ecs/engine/core/localPlayer.js"></script>
		<script src="/ecs/engine/core/cameraControls.js"></script>
		<script src="/ecs/engine/core/keyboardState.js"></script>
		<script src="/ecs/engine/core/keyInputControls.js"></script>
		<script src="/ecs/engine/core/joystickControls.js"></script>
		<script src="/ecs/engine/editor/EditorTab.js"></script>

		<script>

			debugMode = true;
			const Signal = signals.Signal;

		//	Global helpers.

			Number.prototype.format = function (){
				return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
			};

		//	save_file.js
			function saveString( text, filename ) {
				save( new Blob( [ text ], { type: "text/plain" } ), filename );
			}

			function saveArrayBuffer( buffer, filename ) {
				save( new Blob( [ buffer ], { type: "application/octet-stream" } ), filename );
			}

			function save( blob, filename ) {

				var link = document.createElement( "a" );
				link.href = URL.createObjectURL( blob );
				link.download = filename || "untitled";
				link.click();

			}

		//	round.js
			function round(number, precision) {
				var shift = function (number, precision, reverseShift) {
					if (reverseShift) {
						precision = -precision;
					}  
					numArray = ("" + number).split("e");
					return +(numArray[0] + "e" + (numArray[1] ? (+numArray[1] + precision) : precision));
				};
				return shift(Math.round(shift(number, precision, false)), precision, true);
			}

		//	array_move.js
			function array_move( arr, old_index, new_index ){

				if (new_index >= arr.length) {
					var k = new_index - arr.length + 1;
					while (k--) {
						arr.push(undefined);
					}
				}

				arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
			}

		//	deep_copy.js
			function deepCopy(obj) {
				if (Object.prototype.toString.call(obj) === "[object Array]") {
					var out = [], i = 0, len = obj.length;
					for ( ; i < len; i++ ) {
						out[i] = arguments.callee(obj[i]);
					}
				//	console.log("out:", out);
					return out;
				}
				if (typeof obj === "object") {
					var out = {}, i;
					for ( i in obj ) {
						out[i] = arguments.callee(obj[i]);
					}
				//	console.log("out:", out);
					return out;
				}
				return obj;
			}

			function copyObject(obj) {

			//	1. copy has same prototype as orig
				var copy = Object.create(Object.getPrototypeOf(obj));

			//	2. copy has all of origâ€™s properties
				copyOwnPropertiesFrom(copy, obj);

				return copy; // warning: shallow copy!

			//	The properties are copied from orig to copy via this function:

				function copyOwnPropertiesFrom(target, source) {
					Object.getOwnPropertyNames(source).forEach(function(propKey) {
						var desc = Object.getOwnPropertyDescriptor(source, propKey);
						Object.defineProperty(target, propKey, desc);
					});
					return target;
				};

			}

		//	three-quaternion-from-normal.
		//	Builds a ThreeJS quaternion from a normal vector.
		//	This is useful for getting meshes to 'point' in the direction of a vector.

		//	Usage: quat = quaternionFromNormal(normal, [quaternionTarget])
		//	Builds a quaternion from the normal (a normalized THREE.Vector3), 
		//	storing the result in quaternionTarget (a THREE.Quaternion) 
		//	or creating a new quaternion object if no target is specified.
		//	The quaternion target is returned.

		//	Example:
		//	Say we want mesh to point from A to B point.
			//	var A = new THREE.Vector3(1, 0, 0);
			//	var B = new THREE.Vector3(2, 5,-1);
		//	Get normal A->B.
			//	var normal = B.clone().sub(A).normalize();
		//	Get orientation.
			//	var quaternion = quaternionFromNormal(normal);
		//	Apply orientation to mesh.
			//	mesh.quaternion.copy(quaternion);

			function quaternionFromNormal( normal, quaternion ){

				return setDirection(normal, quaternion);

				function setDirection(normal, quaternion) {
					quaternion = quaternion || new THREE.Quaternion();
				//	vector is assumed to be normalized.
					if (normal.y > 0.99999) {
						quaternion.set(0, 0, 0, 1);
					} else if (normal.y < -0.99999) {
						quaternion.set(1, 0, 0, 0);
					} else {
						var axis = new THREE.Vector3();
						axis.set(normal.z, 0, -normal.x).normalize();
						var radians = Math.acos(normal.y);
						quaternion.setFromAxisAngle(axis, radians);
					}

					return quaternion;
				}
			}

		</script>

		<script>

			localPlayer.controller.movementSpeed = 10;

		//	Entities.

			debugMode && (function(){
				var r = 1;
				var geometry = new THREE.BoxGeometry(r,r,r);
				var material = new THREE.MeshLambertMaterial();
				var cube = new THREE.Mesh(geometry, material);
				cube.name = "local player cube";
				localPlayer.add( cube );
			})();

/*
		//	box coluctions.
			(function(){

				var material = new THREE.MeshLambertMaterial();

				(function(){
					var w = 10; var h = 5;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					octree.importThreeMesh( new THREE.Mesh(box) );
					var geometry = new THREE.EdgesGeometry( box );
					var material = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 1";
					scene.add( segments );
				})();

				(function(){
					var w = 10, h = 20;
					var x = 10, y = h/2, z = -4;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "build 2";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 2";
					segments.position.copy( mesh.position );
					scene.add( mesh );
				})();

				(function(){
					var w = 12, h = 10;
					var x = 11, y = h/2, z = -10;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "build 3";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 3";
					segments.position.copy( mesh.position );
					scene.add( mesh );
				})();

				(function(){
					var w = 8, h = 10;
					var x = -10, y = h/2, z = 10;
					var box = new THREE.BoxGeometry(w,h,w);
					box.translate(0, h/2, 0);
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "build 4";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 4";
					segments.position.copy( mesh.position );
					scene.add( mesh );
				})();

				(function(){
					var w = 12, h = 20, d = 2;
					var x = -14, y = h/2, z = 10;
					var box = new THREE.BoxGeometry(w,h,d);
					box.translate(0, h/2, 0);
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "build 5";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 5";
					segments.position.copy( mesh.position );
					scene.add( mesh );
				})();

				(function(){
					var w = 4, h = 20, d = 20;
					var x = -17, y = h/2, z = 12;
					var box = new THREE.BoxGeometry(w,h,d);
					box.translate(0, h/2, 0);
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "build 6";
					mesh.position.set(x,0,z);
					octree.importThreeMesh( mesh );
					var geometry = new THREE.EdgesGeometry( box );
					var segments = new THREE.LineSegments( geometry, material );
					segments.name = "segments 6";
					segments.position.copy( mesh.position );
					scene.add( mesh );
				})();

			})();
*/
		</script>

		<script>
		//	Editor Tab.
		</script>

		<script>

		//	Editor.

		//	Create a Object3D entity 
		//	to hold editor-tab values.
		//	editor will must not added in scene.

			const editor = new THREE.Object3D();
			editor.name = "Editor";
			entities.push({id: editor.id}); // do not push in entities?

			editor.reset = function(){

				editor.copy( new THREE.Object3D() );
				editor.name = "Editor";
				debugMode && console.log( "editor reset:", editor );

			};
			
			editor.update = function( value ){

				var id = parseInt( value );

				if ( id === NaN ) return;
				if ( id === scene.id ) return; // important!
				if ( id === camera.id ) return; // important!
				if ( id === editor.id ) return; // important!
				if ( id === cameraLight.id ) return; // important!
				if ( id === localPlayer.id ) return; // important!
				if ( id === shadowCameraHelper.id ) return; // important!
				if ( id === cameraLight.shadow.camera.id ) return; // important!

				var object = scene.getObjectById(id);

				if ( !object ) return;
				if ( object === scene ) return;
				if ( object === camera ) return;
				if ( object === editor ) return;
				if ( object === cameraLight ) return;
				if ( object === localPlayer ) return;
				if ( object === shadowCameraHelper ) return;
				if ( object === cameraLight.shadow.camera ) return;

				object && object.isObject3D && editor.copy( object );
				debugMode && console.log( "editor update:", editor );
			};

		//	Editor watchers.

			(function(){

				var k = 0;

				const RAD2DEG = THREE.Math.RAD2DEG;
				const DEG2RAD = THREE.Math.DEG2RAD;

				const vect_x_input = document.getElementById("input-vector-x");
				const vect_y_input = document.getElementById("input-vector-y");
				const vect_z_input = document.getElementById("input-vector-z");
				const vect_w_input = document.getElementById("input-vector-w");

				const vect_x_increase = document.getElementById("vector-x-increase");
				const vect_y_increase = document.getElementById("vector-y-increase");
				const vect_z_increase = document.getElementById("vector-z-increase");
				const vect_w_increase = document.getElementById("vector-w-increase");
				const vect_x_decrease = document.getElementById("vector-x-decrease");
				const vect_y_decrease = document.getElementById("vector-y-decrease");
				const vect_z_decrease = document.getElementById("vector-z-decrease");
				const vect_w_decrease = document.getElementById("vector-w-decrease");

				const entity_droplist = document.getElementById("entities-droplist");
				const vector_droplist = document.getElementById("vector-mode-droplist");
				const geometry_droplist = document.getElementById("editor-geometry-droplist");

				const exit_edit_button = document.getElementById("exit-edit-mode");
				const box_geometry_button = document.getElementById("new-box-geometry");
				const reset_vectors_button = document.getElementById("reset-vectors-button");
				const plane_geometry_button = document.getElementById("new-plane-geometry");

				const entitySelect = { value:entity_droplist.value };   // string.
				const vectorSelect = { value:vector_droplist.value };   // string.
				const geometryType = { value:geometry_droplist.value }; // string.

			//	Editor Tab eventListners.

				(function(){

					var object;
					var interval;

					const axisX = new THREE.Vector3(1,0,0);
					const axisY = new THREE.Vector3(0,1,0);
					const axisZ = new THREE.Vector3(0,0,1);

					watch(entitySelect, function( prop, action, newValue, oldValue ){

						var id = parseInt( newValue );
						if ( id === NaN ) return object = undefined;
						if ( id === scene.id ) return object = undefined;
						if ( id === camera.id ) return object = undefined;
						if ( id === editor.id ) return object = undefined;
						if ( id === cameraLight.id ) return object = undefined;
						if ( id === localPlayer.id ) return object = undefined;
						if ( id === shadowCameraHelper.id ) return object = undefined;
						if ( id === cameraLight.shadow.camera.id ) return object = undefined;

						object = scene.getObjectById( id );
						if ( !object ) return object = undefined;
						debugMode && console.log( object );

					});

					function update( button ){

						if ( !object ) return;

						var vector = vectorSelect.value;

						if ( vector === "position" ) {
							var step = 1/100; // 1 cm.
							if ( button === vect_x_increase ) object.position.x += step/10; // 1 mm.
							if ( button === vect_y_increase ) object.position.y += step/10; // 1 mm.
							if ( button === vect_z_increase ) object.position.z += step/10; // 1 mm.
							if ( button === vect_x_decrease ) object.position.x -= step/10; // 1 mm.
							if ( button === vect_y_decrease ) object.position.y -= step/10; // 1 mm.
							if ( button === vect_z_decrease ) object.position.z -= step/10; // 1 mm.
						}

						else if ( vector === "rotation" ) {
							var step = Math.PI/180; // 1 deg.
							if ( button === vect_x_increase ) object.rotateOnAxis( axisX,  step/10 ); // 0.1 deg.
							if ( button === vect_y_increase ) object.rotateOnAxis( axisY,  step/10 ); // 0.1 deg.
							if ( button === vect_z_increase ) object.rotateOnAxis( axisZ,  step/10 ); // 0.1 deg.
							if ( button === vect_x_decrease ) object.rotateOnAxis( axisX, -step/10 ); // 0.1 deg.
							if ( button === vect_y_decrease ) object.rotateOnAxis( axisY, -step/10 ); // 0.1 deg.
							if ( button === vect_z_decrease ) object.rotateOnAxis( axisZ, -step/10 ); // 0.1 deg.
						}

						else if ( vector === "scale" ) {

							var step = 1/100; // 1 %

							if ( button === vect_x_increase ) {
								object.scale.x += step/10;     // 0.1 %.
								if ( Math.abs( object.scale.x ) < step/10 ) 
									object.scale.x = step/10;  // avoid scale.x:0.
							} else if ( button === vect_y_increase ) {
								object.scale.y += step/5;      // 0.1 %.
								if ( Math.abs( object.scale.y ) < step/10 ) 
									object.scale.y = step/10;  // avoid scale.x:0.
							} else if ( button === vect_z_increase ) {
								object.scale.z += step/5;      // 0.1 %.
								if ( Math.abs( object.scale.z ) < step/10 ) 
									object.scale.z = step/10;  // avoid scale.x:0.
							} else if ( button === vect_w_increase ) {
								object.scale.x += step/10;     // 0.1 %.
								object.scale.y += step/10;     // 0.1 %.
								object.scale.z += step/10;     // 0.1 %.
								if ( Math.abs( object.scale.x ) < step/10 ) 
									object.scale.x = step/10;  // avoid scale.x:0.
								if ( Math.abs( object.scale.y ) < step/10 ) 
									object.scale.y = step/10;  // avoid scale.y:0.
								if ( Math.abs( object.scale.z ) < step/10 ) 
									object.scale.z = step/10;  // avoid scale.z:0.
							} else if ( button === vect_x_decrease ) {
								object.scale.x -= step/10;     // 0.1 %,
								if ( Math.abs( object.scale.x ) < step/10 ) 
									object.scale.x = -step/10; // avoid scale.x:0,
							} else if ( button === vect_y_decrease ) {
								object.scale.y -= step/10;     // 0.1 %,
								if ( Math.abs( object.scale.y ) < step/10 ) 
									object.scale.y = -step/10; // avoid scale.y:0,
							} else if ( button === vect_z_decrease ) {
								object.scale.z -= step/10;     // 0.1 %,
								if ( Math.abs( object.scale.z ) < step/10 ) 
									object.scale.z = -step/10; // avoid scale.z:0,
							} else if ( button === vect_w_decrease ) {
								object.scale.x -= step/10;     // 0.1 %,
								object.scale.y -= step/10;     // 0.1 %,
								object.scale.z -= step/10;     // 0.1 %,
								if ( Math.abs( object.scale.x ) < step/10 ) 
									object.scale.x = -step/10; // avoid scale.x:0,
								if ( Math.abs( object.scale.y ) < step/10 ) 
									object.scale.y = -step/10; // avoid scale.y:0,
								if ( Math.abs( object.scale.z ) < step/10 ) 
									object.scale.z = -step/10; // avoid scale.z:0,
							}
						}

						else if ( vector === "quaternion" ) {
							var step = 1/100;
							if ( button === vect_x_increase ) object.quaternion.x += step/10; // 0.001
							if ( button === vect_y_increase ) object.quaternion.y += step/10; // 0.001
							if ( button === vect_z_increase ) object.quaternion.z += step/10; // 0.001
							if ( button === vect_w_increase ) object.quaternion.w += step/10; // 0.001

							if ( button === vect_x_decrease ) object.quaternion.x -= step/10; // 0.001
							if ( button === vect_y_decrease ) object.quaternion.y -= step/10; // 0.001
							if ( button === vect_z_decrease ) object.quaternion.z -= step/10; // 0.001
							if ( button === vect_w_decrease ) object.quaternion.w -= step/10; // 0.001
						}

					}

					function onMouseDown(){ 

						if ( !object ) return;

						var button = this;
						var clock = new THREE.Clock();
						interval = setTimeout( function onUpdate() {
							if ( !object ) return;
							var dt = clock.getDelta();
							object && update( button );
							interval = setTimeout( onUpdate, dt );
						//	debugMode && console.log( "on Update:", interval );

						}, 500);
					}

					function onMouseClick(){ 

						clearTimeout( interval ); // important!

						if ( !object ) return;
						object && update( this );

						debugMode && console.log( "on Mouse Click:", interval );
					}

					vect_x_increase.addEventListener( "mousedown", onMouseDown );
					vect_y_increase.addEventListener( "mousedown", onMouseDown );
					vect_z_increase.addEventListener( "mousedown", onMouseDown );
					vect_w_increase.addEventListener( "mousedown", onMouseDown );
					vect_x_decrease.addEventListener( "mousedown", onMouseDown );
					vect_y_decrease.addEventListener( "mousedown", onMouseDown );
					vect_z_decrease.addEventListener( "mousedown", onMouseDown );
					vect_w_decrease.addEventListener( "mousedown", onMouseDown );

					window.addEventListener( "mouseup", function (){
						clearTimeout( interval ); // important!
					//	debugMode && console.log( "on MouseUp:", interval );
					});

					vect_x_increase.addEventListener( "click", onMouseClick );
					vect_y_increase.addEventListener( "click", onMouseClick );
					vect_z_increase.addEventListener( "click", onMouseClick );
					vect_w_increase.addEventListener( "click", onMouseClick );
					vect_x_decrease.addEventListener( "click", onMouseClick );
					vect_y_decrease.addEventListener( "click", onMouseClick );
					vect_z_decrease.addEventListener( "click", onMouseClick );
					vect_w_decrease.addEventListener( "click", onMouseClick );

					vect_x_input.addEventListener( "change", function(){

						this.blur(); // important!
						var vector = vectorSelect.value;
						var thisValue = parseFloat( this.value );

						if ( !object ) 
							return void( this.value = editor[vector].x.toFixed(2) );
						else if ( vector === "scale" ) {
							if ( !thisValue ) 
								return void( object.scale.x = 0.001 ); // avoid scale.x:0/NaN,
							else object.scale.x = thisValue/100;
							if ( Math.abs( object.scale.x ) < 0.001 ) object[ vector ].x = 0.001; 
						} 
						else if ( thisValue == NaN )
							return void( this.value = editor[vector].x.toFixed(2) );
						else if ( vector === "rotation" )
							object[ vector ].x = DEG2RAD*thisValue;
						else
							object[ vector ].x = thisValue;
					});

					vect_y_input.addEventListener( "change", function(){

						this.blur(); // important!
						var vector = vectorSelect.value;
						var thisValue = parseFloat( this.value );

						if ( !object ) 
							return void( this.value = editor[vector].y.toFixed(2) );
						else if ( vector === "scale" ) {
							if ( !thisValue ) 
								return void( object.scale.y = 0.001 ); // avoid scale.y:0/NaN,
							else object.scale.y = thisValue/100;
							if ( Math.abs( object.scale.y ) < 0.001 ) object[ vector ].y = 0.001; 
						} 
						else if ( thisValue == NaN )
							return void( this.value = editor[vector].y.toFixed(2) );
						else if ( vector === "rotation" )
							object[vector].y = DEG2RAD*thisValue;
						else
							object[vector].y = thisValue;
					});

					vect_z_input.addEventListener( "change", function(){

						this.blur(); // important!
						var vector = vectorSelect.value;
						var thisValue = parseFloat( this.value );

						if ( !object || thisValue == NaN ) 
							return void( this.value = editor[vector].z.toFixed(2) );
						else if ( vector === "scale" ) {
							if ( !thisValue ) 
								return void( object.scale.z = 0.001 ); // avoid scale.z:0/NaN,
							else object.scale.z = thisValue/100;
							if ( Math.abs( object.scale.z ) < 0.001 ) object[ vector ].z = 0.001; 
						} 
						else if ( thisValue == NaN )
							return void( this.value = editor[vector].z.toFixed(2) );
						else if ( vector === "rotation" )
							object[vector].z = DEG2RAD*thisValue;
						else
							object[vector].z = thisValue;
					});

					vect_w_input.addEventListener( "change", function(){

						this.blur(); // important!
						var vector = vectorSelect.value;
						var thisValue = parseFloat( this.value );

						if ( !object ) {
							return void( this.value = NaN );
						} else if ( vector === "rotation" ) {
							this.value = object.rotation.order;
						} else if ( vector === "scale" ) {
							if ( !thisValue ) {
								object.scale.x = 0.001; // avoid scale.x:0/NaN,
								object.scale.y = 0.001; // avoid scale.y:0/NaN,
								object.scale.z = 0.001; // avoid scale.z:0/NaN,
							//	this.value = 0.1.toFixed(2);
							} else {
								object.scale.x = thisValue/100;
								object.scale.y = thisValue/100;
								object.scale.z = thisValue/100;
							}
							if ( Math.abs( object.scale.x ) < 0.001 ) object.scale.x = 0.001; 
							if ( Math.abs( object.scale.y ) < 0.001 ) object.scale.y = 0.001; 
							if ( Math.abs( object.scale.z ) < 0.001 ) object.scale.z = 0.001; 
						//	this.value = ( 100*(object.scale.x+object.scale.y+object.scale.z)/3 ).toFixed(2)
						} else if ( thisValue == NaN ) { 
						//	reset quaternion.
							object.scale.set(1,1,1);
							object.rotation.set(0,0,0);
							object.quaternion.set(0,0,0,1);
							object.updateMatrixWorld(true); // important?
							editor.copy( object );          // important?
						} else if ( vector === "quaternion" ) {
							object.quaternion.w = thisValue;
						} else this.value = editor[vector].w;
					});

				//	Move on axis Y (up/down).

					function translateOnScreenAxisY( dt, object, mode, down ){
						if ( !object ) return;
						var rad = 0;
						var verticalAngle;
						var movementSpeed = Math.max(dt, 0.01); // step.
						var cameraFrontAngle = cameraControls.phi;
						if (down) verticalAngle = -Math.PI/2; // down.
						else verticalAngle      =  Math.PI/2; // up.
						var direction = rad - cameraFrontAngle + verticalAngle;
						var directionOnAxisY = Math.sin(direction);
						var y = directionOnAxisY * movementSpeed;
						object[mode].y += y; 

					}

				//	Move on plane XZ (left/right/forwards/backward).

					function translateOnScreenPlaneXZ( dt, object, mode ) {
						if ( !object ) return;
						var rad = 2 * Math.PI;  // keyboard input.
						var movementSpeed = Math.max(dt, 0.01); // step.
						var cameraFrontAngle = rad + cameraControls.theta;
					//	var keyboardFrontAngle = keyboard.frontAngle;
						var direction = rad - cameraFrontAngle; // + keyboard.frontAngle;
						var directionOnAxisX = -Math.sin(direction);
						var directionOnAxisZ = -Math.cos(direction);
						var x = directionOnAxisX * movementSpeed;
						var z = directionOnAxisZ * movementSpeed;
						object[mode].x += x; 
						object[mode].z += z;

					}

				})();

			//	Droplists.

				entity_droplist.addEventListener("change", function(){
					entity_droplist.blur();
					entitySelect.value = entity_droplist.value;
				});

				vector_droplist.addEventListener("change", function(){
					vector_droplist.blur();
					vectorSelect.value = vector_droplist.value;

				});

				geometry_droplist.addEventListener("change", function(){
					geometry_droplist.blur();
					geometryType.value = geometry_droplist.value;
				});

			//	Buttons.

				exit_edit_button.addEventListener( "click", function(){
					entitySelect.value = entity_droplist.value = "";
				//	entity_droplist.dispatchEvent(new Event("change"));
				});


			//	Editor Tab watchers.

				watch(vectorSelect, function( prop, action, newValue, oldValue ){
					debugMode && console.log( "vector droplist:", prop, action, newValue );

				//	Update vectors direct from editor.
					displayVectorValues( vectorSelect.value );

				});

				watch(entitySelect, function( prop, action, newValue, oldValue ){
					debugMode && console.log( "entity droplist:", prop, action, newValue  );

					editor.reset(); // important!

				//	Update old octree (first) important!
					if ( oldValue != "" ) updateOctree( oldValue );

				//	Exit edit mode.
					if ( newValue == "" ) exitFromEditMode();

				//	Switch to edit mode.
					if ( newValue != "" ) switchToEditMode( newValue );

				//	Display vectors direct from editor.
				//	callWatchers(vectorSelect, "value");
					displayVectorValues( vectorSelect.value );

				});

				function displayVectorValues( vector ){

					if ( vector === "position" ) {
						vect_x_input.value = ( editor[ vector ].x ).toFixed(3);
						vect_y_input.value = ( editor[ vector ].y ).toFixed(3);
						vect_z_input.value = ( editor[ vector ].z ).toFixed(3);
						vect_w_input.value = NaN;
					}

					else if ( vector === "rotation" ) {
						vect_x_input.value = ( RAD2DEG*editor[ vector ].x ).toFixed(2);
						vect_y_input.value = ( RAD2DEG*editor[ vector ].y ).toFixed(2);
						vect_z_input.value = ( RAD2DEG*editor[ vector ].z ).toFixed(2);
						vect_w_input.value = editor[ vector ].order;
					} 

					else if ( vector === "scale" ) {
						vect_x_input.value = ( 100*editor[ vector ].x ).toFixed(2);
						vect_y_input.value = ( 100*editor[ vector ].y ).toFixed(2);
						vect_z_input.value = ( 100*editor[ vector ].z ).toFixed(2);
						vect_w_input.value = ( 100*(editor[vector].x + editor[vector].y + editor[vector].z) / 3 ).toFixed(2);
					}

					else if ( vector === "quaternion" ) {
						vect_x_input.value = ( editor[ vector ].x ).toFixed(3);
						vect_y_input.value = ( editor[ vector ].y ).toFixed(3);
						vect_z_input.value = ( editor[ vector ].z ).toFixed(3);
						vect_w_input.value = ( editor[ vector ].w ).toFixed(3);
					}

					else {
						vect_x_input.value = ( editor[ vector ].x ).toFixed(2);
						vect_y_input.value = ( editor[ vector ].y ).toFixed(2);
						vect_z_input.value = ( editor[ vector ].z ).toFixed(2);
						vect_w_input.value = NaN;
					}

				}

			//	Editor Object3D watchers.

				watch( editor, "type", function(prop, action, newValue, oldValue){
					debugMode && console.log( "type:", prop, action, newValue );
				});

				watch( editor, "visible", function(prop, action, newValue, oldValue){
					debugMode && console.log( "visible:", prop, action, newValue );
				});

				watch( editor.position, function(prop, action, newValue, oldValue){
				//	debugMode && console.log( "position:", prop, action, newValue );
					if ( newValue === undefined ) return;
					if ( vectorSelect.value !== "position" ) return;
					if ( prop === "x" ) vect_x_input.value = newValue.toFixed(3);
					if ( prop === "y" ) vect_y_input.value = newValue.toFixed(3);
					if ( prop === "z" ) vect_z_input.value = newValue.toFixed(3);
				});

				watch( editor.rotation, function(prop, action, newValue, oldValue){
				//	debugMode && console.log( "rotation:", prop, action, newValue );
					if ( newValue === undefined ) return;
					if ( vectorSelect.value !== "rotation" ) return;
					if ( prop === "_x" ) vect_x_input.value = (RAD2DEG*newValue).toFixed(2);
					if ( prop === "_y" ) vect_y_input.value = (RAD2DEG*newValue).toFixed(2);
					if ( prop === "_z" ) vect_z_input.value = (RAD2DEG*newValue).toFixed(2);
				});

				watch( editor.scale, function(prop, action, newValue, oldValue){
				//	debugMode && console.log( "scale:", prop, action, newValue );
					if ( newValue === undefined ) return;
					if ( vectorSelect.value !== "scale" ) return;
					if ( prop === "x" ) vect_x_input.value = (100*newValue).toFixed(2);
					if ( prop === "y" ) vect_y_input.value = (100*newValue).toFixed(2);
					if ( prop === "z" ) vect_z_input.value = (100*newValue).toFixed(2);
					vect_w_input.value = (100 * ( ( editor.scale.x+editor.scale.y+editor.scale.z )/3 ) ).toFixed(2);
				});

				watch( editor.quaternion, function(prop, action, newValue, oldValue){
				//	debugMode && console.log( "quaternion:", prop, action, newValue );
					if ( newValue === undefined ) return;
					if ( vectorSelect.value !== "quaternion" ) return;
					if ( prop === "_x" ) vect_x_input.value = newValue.toFixed(3);
					if ( prop === "_y" ) vect_y_input.value = newValue.toFixed(3);
					if ( prop === "_z" ) vect_z_input.value = newValue.toFixed(3);
					if ( prop === "_w" ) vect_w_input.value = newValue.toFixed(3);

				});

				function updateOctree( value ){
					var id = parseInt( value );
					if ( id === NaN ) return;
					var object = scene.getObjectById( id );
					if ( !object ) return;
					if ( !object.isMesh ) return;
					if ( !object.geometry ) return;
					var uuid = object.geometry.uuid;
					octree.removeThreeMesh( uuid );
					if ( !localPlayer.getObjectById(object.id) ) {
						octree.importThreeMesh( object );
					}
				}

				function exitFromEditMode(){
					takeCameraControls( localPlayer );
					keyInputControls.isDisabled = false;
					entitySelect.value = entity_droplist.value = "";
					return void(0);
				}

				function switchToEditMode( value ){

					var id = parseInt( value );
					if ( id === NaN ) return exitFromEditMode();
					if ( id === scene.id ) return exitFromEditMode();
					if ( id === camera.id ) return exitFromEditMode();
					if ( id === editor.id ) return exitFromEditMode();
					if ( id === localPlayer.id ) return exitFromEditMode();
					if ( id === cameraLight.id ) return exitFromEditMode();
					if ( id === shadowCameraHelper.id ) exitFromEditMode();
					if ( id === cameraLight.shadow.camera.id ) exitFromEditMode();

					var object = scene.getObjectById( id );
					if ( !object ) return exitFromEditMode();
					if ( object === scene ) return exitFromEditMode();
					if ( object === camera ) return exitFromEditMode();
					if ( object === editor ) return exitFromEditMode();
					if ( object === cameraLight ) return exitFromEditMode();
					if ( object === localPlayer ) return exitFromEditMode();
					if ( object === shadowCameraHelper ) exitFromEditMode();
					if ( object === cameraLight.shadow.camera ) exitFromEditMode();

				//	Take camera controls.
					if ( object.geometry && object.geometry.boundingSphere ) {
						var offset = object.geometry.boundingSphere.center;
						cameraControls.trackObject = object;
						cameraControls.offset.copy( offset );
						cameraControls.offset.y *= 0.5;
					} else takeCameraControls( object );

				//	Update editor object.
					editor.update( id );
				//	Disable key input controls.
					keyInputControls.isDisabled = true;

				}

			//	Geometry.

				plane_geometry_button.addEventListener( "click", function(){

					var material = new THREE.MeshStandardMaterial({side:2});
				//	var entity_droplist = document.getElementById("entities-droplist");

				//	Create plane.
					var w = 1, h = 1, d = 1;
					var x = 0, y = h/2, z =  0;
					var plane = new THREE.PlaneGeometry(w,h,d);
					plane.translate(0, h/2, 0);
					var mesh = new THREE.Mesh(plane, material);
					mesh.name = "plane "+ k++;
					mesh.position.set(x,0,z);
					scene.add( mesh );

				//	Create entity.
					entities.push({id:mesh.id})

				//	Create option.
					var name = mesh.name;
					var uuid = mesh.uuid;
					var option = document.createElement("option");
					var text = ""+mesh.id+"."+mesh.type+":"+mesh.name;
					option.text = text;
					option.value = mesh.id;
					entity_droplist.appendChild( option );

				//	Set new value.
					entitySelect.value = entity_droplist.value = ""+mesh.id;
				//	entity_droplist.dispatchEvent(new Event("change")); // important!

				});

				box_geometry_button.addEventListener( "click", function(){

					var material = new THREE.MeshStandardMaterial();
				//	var entity_droplist = document.getElementById("entities-droplist");

				//	Create box.
					var w = 1, h = 1, d = 1;
					var x = 0, y = h/2, z =  0;
					var box = new THREE.BoxGeometry(w,h,d);
				//	box.translate(0, h/2, 0);
					var mesh = new THREE.Mesh(box, material);
					mesh.name = "box "+ k++;
					mesh.position.set(x,0,z);
					scene.add( mesh );

				//	Create entity.
					entities.push({id:mesh.id})

				//	Create option.
					var name = mesh.name;
					var uuid = mesh.uuid;
					var option = document.createElement("option");
					var text = ""+mesh.id+"."+mesh.type+":"+mesh.name;
					option.text = text;
					option.value = mesh.id;
					entity_droplist.appendChild( option );

				//	Set new value.
					entitySelect.value = entity_droplist.value = ""+mesh.id;
				//	entity_droplist.dispatchEvent(new Event("change")); // important!

				});

			})();

			//	if ( button === vect_x_increase ) object.scale.x += step/10; // 0.1 %.
			//	if ( button === vect_y_increase ) object.scale.y += step/10; // 0.1 %.
			//	if ( button === vect_z_increase ) object.scale.z += step/10; // 0.1 %.
			//	if ( button === vect_w_increase ) {
			//		object.scale.x += step/10; // 0.1 %.
			//		object.scale.y += step/10; // 0.1 %.
			//		object.scale.z += step/10; // 0.1 %.
			//	}
			//
			//	if ( button === vect_x_decrease ) object.scale.x -= step/10; // 0.1 %.
			//	if ( button === vect_y_decrease ) object.scale.y -= step/10; // 0.1 %.
			//	if ( button === vect_z_decrease ) object.scale.z -= step/10; // 0.1 %.
			//	if ( button === vect_w_decrease ) {
			//		object.scale.x -= step/10; // 0.1 %.
			//		object.scale.y -= step/10; // 0.1 %.
			//		object.scale.z -= step/10; // 0.1 %.
			//	}

			//	vect_x_increase.addEventListener("click", function(){
			//		clearTimeout(interval);
			//		interval = setTimeout(function(){
			//			vect_x_increase.active = !vect_x_increase.active;
			//		});
			//	});

			//	vect_x_decrease.addEventListener("click", function(){
			//		clearTimeout(interval);
			//		interval = setTimeout(function(){
			//			vect_x_decrease.active = !vect_x_decrease.active;
			//		});
			//	});

			//	var step = Math.max(dt, 0.01);
			//	var id = parseInt(entitySelect.value);
			//	var object = scene.getObjectById( id );
			//	if ( !(object && object.geometry && object.position) ) return;
			//	object[vectorSelect.value].x += step;

			//	var step = Math.max(dt, 0.01);
			//	var id = parseInt(entitySelect.value);
			//	var object = scene.getObjectById( id );
			//	if ( !(object && object.geometry && object.position) ) return;
			//	object[vectorSelect.value].x -= step;


			//	const clock = new THREE.Clock();
			//	(function update(){
			//		var dt = clock.getDelta();
			//		requestFrameID = requestAnimationFrame( update );
			//		if ( !object ) return; // important!
			//		var step = Math.max(dt, 0.01);
			//		var mode = vectorSelect.value;
			//	})();

			//	if ( mode === "position" ) {
			//
			//		vect_x_increase.active && translateOnScreenPlaneXZ( dt, object, mode );
			//		vect_y_increase.active && translateOnScreenAxisY(   dt, object, mode );
			//		vect_z_increase.active && translateOnScreenPlaneXZ( dt, object, mode );
			//
			//		vect_x_decrease.active && translateOnScreenPlaneXZ( dt, object, mode );
			//		vect_y_decrease.active && translateOnScreenAxisY(   dt, object, mode, true );
			//		vect_z_decrease.active && translateOnScreenPlaneXZ( dt, object, mode );
			//	}

			//	else if ( mode === "rotation" ) {
			//
			//		vect_x_increase.active && object.rotateOnAxis( axisX,  step );
			//		vect_y_increase.active && object.rotateOnAxis( axisY,  step );
			//		vect_z_increase.active && object.rotateOnAxis( axisZ,  step );
			//
			//		vect_x_decrease.active && object.rotateOnAxis( axisX, -step );
			//		vect_y_decrease.active && object.rotateOnAxis( axisY, -step );
			//		vect_z_decrease.active && object.rotateOnAxis( axisZ, -step );
			//	}

			//	else if ( mode === "scale" ) {
			//
			//		if ( vect_x_increase.active ) translateOnScreenPlaneXZ( dt, object, mode );
			//		if ( vect_y_increase.active ) translateOnScreenAxisY(   dt, object, mode );
			//		if ( vect_z_increase.active ) translateOnScreenPlaneXZ( dt, object, mode );
			//
			//		if ( vect_x_decrease.active ) translateOnScreenPlaneXZ( dt, object, mode );
			//		if ( vect_y_decrease.active ) translateOnScreenAxisY(   dt, object, mode, true );
			//		if ( vect_z_decrease.active ) translateOnScreenPlaneXZ( dt, object, mode );
			//	}

			//	else if ( mode === "quaternion" ) {
			//
			//	//	if ( vect_w_decrease.active ) ...
			//	//	if ( vect_w_increase.active ) ...
			//
			//	}


			//	function onMouseUp(){
			//		clearTimeout( interval );
			//		vect_x_increase.active = false;
			//		vect_y_increase.active = false;
			//		vect_z_increase.active = false;
			//		vect_w_increase.active = false;
			//		vect_x_decrease.active = false;
			//		vect_y_decrease.active = false;
			//		vect_z_decrease.active = false;
			//		vect_w_decrease.active = false;
			//		debugMode && console.log( 
			//			"on Mouse Up:", 
			//			vect_x_increase.active && 
			//			vect_y_increase.active && 
			//			vect_z_increase.active && 
			//			vect_w_increase.active && 
			//			vect_x_decrease.active && 
			//			vect_y_decrease.active && 
			//			vect_z_decrease.active && 
			//			vect_w_decrease,
			//		);
			//	});

		</script>

		<script>

		//	Editor systems.

			const axisX = new THREE.Vector3(1,0,0);
			const axisY = new THREE.Vector3(0,1,0);
			const axisZ = new THREE.Vector3(0,0,1);
			const keyboard = new KeyboardState();
			const keyCodes = keyboard.keyCodes;
			const entity_droplist = document.getElementById("entities-droplist"); // important!

			//	var E = keyCodes[69];  var Q = keyCodes[81]; //  key "E",    key "Q"
			//	var D = keyCodes[68];  var A = keyCodes[65]; //  key "D",    key "A"
			//	var W = keyCodes[87];  var S = keyCodes[83]; //  key "W",    key "S"
			//	var R = keyCodes[82];  var F = keyCodes[70]; //  key "R",    key "F"
			//	var Z = keyCodes[90];  var X = keyCodes[88]; //  key "Z",    key "X"
			//	var C = keyCodes[67];  var V = keyCodes[86]; //  key "C",    key "V"

			//	var up       = keyCodes[33] || keyCodes[69]; // "page UP"     or "E"
			//	var down     = keyCodes[34] || keyCodes[81]; // "page DOWN"   or "Q"
			//	var left     = keyCodes[37] || keyCodes[68]; // "arrow LEFT"  or "D"
			//	var right    = keyCodes[39] || keyCodes[65]; // "arrow RIGHT" or "A"
			//	var forwards = keyCodes[38] || keyCodes[87]; // "arrow UP"    or "W"
			//	var backward = keyCodes[40] || keyCodes[83]; // "arrow DOWN"  or "S"

			window.addEventListener("keyup",   function(){ updateKeyboardFrontAngle( keyboard ); });
			window.addEventListener("keydown", function(){ updateKeyboardFrontAngle( keyboard ); });

			function updateKeyboardFrontAngle( keyboard ){

				const rad = Math.PI/4;
				const keyCodes = keyboard.keyCodes;
				var A=65, D=68, S=83, W=87;
				var Left=37, Up=38, Right=39, Down=40;

				var UP    = keyCodes[W] || keyCodes[Up];
				var LEFT  = keyCodes[A] || keyCodes[Left];
				var DOWN  = keyCodes[S] || keyCodes[Down];
				var RIGHT = keyCodes[D] || keyCodes[Right];

			//	debugMode && console.log( UP, LEFT, DOWN, RIGHT );

				if (  UP && !LEFT && !DOWN && !RIGHT ) keyboard.frontAngle = 0 * rad; //   0 deg.
				else if (  UP &&  LEFT && !DOWN && !RIGHT ) keyboard.frontAngle = 1 * rad; //  45 deg.
				else if ( !UP &&  LEFT && !DOWN && !RIGHT ) keyboard.frontAngle = 2 * rad; //  90 deg.
				else if ( !UP &&  LEFT &&  DOWN && !RIGHT ) keyboard.frontAngle = 3 * rad; // 135 deg.
				else if ( !UP && !LEFT &&  DOWN && !RIGHT ) keyboard.frontAngle = 4 * rad; // 180 deg.
				else if ( !UP && !LEFT &&  DOWN &&  RIGHT ) keyboard.frontAngle = 5 * rad; // 225 deg.
				else if ( !UP && !LEFT && !DOWN &&  RIGHT ) keyboard.frontAngle = 6 * rad; // 270 deg.
				else if (  UP && !LEFT && !DOWN &&  RIGHT ) keyboard.frontAngle = 7 * rad; // 315 deg.
			//	else if ( !UP && !LEFT && !DOWN && !RIGHT ) keyboard.frontAngle = 8 * rad; // 360 deg.

			}

		//	const clock = new THREE.Clock();

			(function update(){

			//	EditMode Loop.

				var dt = clock.getDelta();
				requestFrameID = requestAnimationFrame( update );

				for (var i = 0; i < entities.length; i++){

					var entity = entities[i];
					if ( entity.id === scene.id ) continue; // important!
					if ( entity.id === camera.id ) continue; // important!
					if ( entity.id === editor.id ) continue; // important!
					if ( entity.id === localPlayer.id ) continue; // important!
					if ( entity.id === cameraLight.id ) continue; // important!
					if ( entity.id === shadowCameraHelper.id ) continue; // important!

					EditorScalingSystem(dt, entity);
					EditorRotationSystem(dt, entity);
					EditorTranslationSystem(dt, entity);

				}

			})();

		//	## EditorRotationSystem.

			function EditorRotationSystem(dt, entity){

				try {

					if ( entity.id.toString() != entity_droplist.value ) return;

					var object = scene.getObjectById( entity.id );
					var required = object && object.geometry && object.rotation;
					if ( !required ) return; // important!

					var rad = Math.max(dt, 0.02);
					var keyCodes = keyboard.keyCodes;
					var UP=38, DOWN=40, LEFT=37, RIGHT=39;
					var D=68, A=65, W=87, S=83, R=82, F=70;

				//	Rotation (local coordinates).
					keyCodes[ UP ]  && object.rotateOnAxis( axisX,  rad );
					keyCodes[DOWN]  && object.rotateOnAxis( axisX, -rad );
					keyCodes[LEFT]  && object.rotateOnAxis( axisY, -rad );
					keyCodes[RIGHT] && object.rotateOnAxis( axisY,  rad );

				//	Reset rotation.
					keyCodes[R] && object.rotation.set(0,0,0);
					keyCodes[F] && object.setRotationFromQuaternion(camera.quaternion);

				//	Update editor object.
					object && object.rotation && editor.rotation.copy( object.rotation ); // important!

				} catch(err){
					debugMode && console.error( "EditorRotationError:", err );
				};

			}

		//	## EditorTranslationSystem.

			function EditorTranslationSystem(dt, entity){

				try {

					if ( entity.id.toString() != entity_droplist.value ) return;

					var object = scene.getObjectById( entity.id );
					var required = object && object.geometry && object.position;
					if ( !required ) return; // important!

					var keyCodes = keyboard.keyCodes;
					var object = scene.getObjectById( entity.id );
					var LEFT=37, RIGHT=39, UP=38, DOWN=40;
					var A=65, D=68, E=69, F=70, Q=81, R=82, S=83, W=87;

				//	Move up/down.

					if ( keyCodes[E] || keyCodes[Q] ) (function(up, down){

						var rad = 0;
						var keyboardFrontAngle = 0;
						var movementSpeed = Math.max(dt, 0.05);
						var cameraFrontAngle = cameraControls.phi;
						if ( up ) keyboardFrontAngle =  Math.PI/2;
						if (down) keyboardFrontAngle = -Math.PI/2;
						var direction = rad - cameraFrontAngle + keyboardFrontAngle;
						var directionOnAxisY = Math.sin(direction);
						var y = directionOnAxisY * movementSpeed;
						object.position.y += y; 

					})( keyCodes[E], keyCodes[Q] );

				//	Move left/right/forwards/backward

					if (  keyCodes[W] || keyCodes[A] 
						|| keyCodes[S] || keyCodes[D] ) (function() {

					//	var rad = 6 * Math.PI/4;  // joystick input.
						var rad = 8 * Math.PI/4;  // keyboard input.
						var movementSpeed = Math.max(dt, 0.05);
						var cameraFrontAngle = cameraControls.getFrontAngle();
						var keyboardFrontAngle = keyboard.frontAngle;
						var direction = rad - cameraFrontAngle + keyboardFrontAngle;
						var directionOnAxisX = -Math.sin(direction);
						var directionOnAxisZ = -Math.cos(direction);
						var x = directionOnAxisX * movementSpeed;
						var z = directionOnAxisZ * movementSpeed;
						object.position.x += x; 
						object.position.z += z;

					})();

				//	Update editor object.
					object && object.position && editor.position.copy( object.position ); // important!

				} catch(err){
					debugMode && console.error( "EditorTranslationError:", err );
				};

			}

		//	## EditorScalingSystem.

			function EditorScalingSystem(dt, entity){

				try {

					if ( entity.id.toString() != entity_droplist.value ) return;

					var object = scene.getObjectById( entity.id );
					var required = object && object.geometry && object.scale;
					if ( !required ) return; // important!

					//	TODO.

				//	Update editor object.
					object && object.scale && editor.scale.copy( object.scale ); // important!

				} catch(err){
					debugMode && console.error( "EditorScalingError:", err );
				};

			}


		//	!!! DEMO !!! VERY IMPORTANT! !!! DEMO !!! VERY IMPORTANT! !!! DEMO !!!

			function translateOnScreenAxis( object ){
			//	(from MW character controller).
			//	var rad = 3 * Math.PI/2 // joystick input.
				var rad = 2 * Math.PI;  // keyboard input.
				var movementSpeed = 0.05; // (m/fps) => 5cm/fps
				var cameraFrontAngle = cameraControls.getFrontAngle();
				var keyboardFrontAngle = keyboard.frontAngle;
				var direction = rad - cameraFrontAngle + keyboardFrontAngle;
				var directionOnAxisX = -Math.sin(direction);
				var directionOnAxisZ = -Math.cos(direction);
				var x = directionOnAxisX * movementSpeed;
				var z = directionOnAxisZ * movementSpeed;
				var velocity = new THREE.Vector3(x,0,z);
				object.position.x += velocity.x; 
				object.position.z += velocity.z;
			}

		//	!!! DEMO !!! VERY IMPORTANT! !!! DEMO !!! VERY IMPORTANT! !!! DEMO !!!

		//		if ( !entity.isRotated && ( 
		//		keyCodes[A]    || keyCodes[W]    || 
		//		keyCodes[S]    || keyCodes[D]    ||
		//		keyCodes[UP]   || keyCodes[DOWN] ||
		//		keyCodes[LEFT] || keyCodes[RIGHT] ) ) (function() {
		//		//	var rad = 6 * Math.PI/4;  // joystick input.
		//			var rad = 8 * Math.PI/4;  // keyboard input.
		//			var movementSpeed = Math.max(dt, 0.05);
		//			var cameraFrontAngle = cameraControls.getFrontAngle();
		//			var keyboardFrontAngle = keyboard.frontAngle;
		//			var direction = rad - cameraFrontAngle + keyboardFrontAngle;
		//			var directionOnAxisX = -Math.sin(direction);
		//			var directionOnAxisZ = -Math.cos(direction);
		//			var x = directionOnAxisX * movementSpeed;
		//			var z = directionOnAxisZ * movementSpeed;
		//			object.position.x += x; 
		//			object.position.z += z;
		//		})();
		//
		//	//	Reset.
		//		if ( keyCodes[R] ) object.rotation.set(0,0,0);
		//		if ( keyCodes[F] ) object.setRotationFromQuaternion(camera.quaternion);

		</script>

		<script>

		//	Loading systems.

			function FBXLoadSystem( entity ){

				var s = entity.scale;
				var url = entity.url;
				var loader = new THREE.FBXLoader();
				loader.load( url, function( group ){
					debugMode && console.log( group );
					entities.push({id: group.id});

				//	All children in group have scale 100.
					group.traverse(function( child ){

					//	Reset scale.
						if ( child.scale !== undefined ) {
							child.scale.set(1,1,1);
						}

					//	Create child entities.
						if ( child.type == "Mesh" 
						  || child.type == "SkinnedMesh" ) {
						//	Add entity.
							entities.push({id: child.id});
						//	Create option.
							(function createOption(){
								var select = document.getElementById("entities-droplist");
								if ( !select ) return;
								var option = document.createElement("option");
								option.value = child.id;
								option.text = ""+child.id+"."+child.type+":"+child.name;
								select.appendChild( option );
							})();
						}

					});

				//	Set scale.
					if ( entity.scale ) group.scale.set(s,s,s);

				//	if ( group.animations && group.animations.length ){
					//	Create clip entities.
					//	Create animation controller.
				//	}

				//	Add removed flag.
					entity.removed = true;

				});
			}

		</script>

		<script>

		//	Create options, add entities.

			(function(){

				var select = document.getElementById("entities-droplist");

				scene.traverse(function( object ){
					var name = object.name;
					var uuid = object.uuid;
					var option = document.createElement("option");
					var text = ""+object.id+"."+object.type+":"+object.name;
					option.text = text;
					option.value = object.id;
					select.appendChild( option );
					entities.push({id: object.id}); // important!
				});

				select.value = ""; // important!

			})();

		</script>

	</body>
</html>
