<!DOCTYPE html>
<html lang="en">
	<head>

		<title>Legacy ECS Engine (pre-alpha 0.9)</title>

		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">
		<link rel="stylesheet" href="/css/jcrop.css">

		<script src="/js/watch.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>
		<script src="/js/jcrop.js"></script>

		<style>

			body {
				margin: 0px;
				font-size: 13px;
				font-family: sans-serif;
				background-repeat: repeat;
				background-image: url("https://i.imgur.com/rnZZU0i.png") !important;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-matcap,
			.btn-terrain {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}

			.btn-matcap + .btn-matcap,
			.btn-terrain + .btn-terrain {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/ecs/js/three.js"></script>
		<script src="/ecs/js/TabUI.js"></script>
		<script src="/ecs/js/MeshWalk.js"></script>
		<script src="/ecs/js/UVsDebug.js"></script>
		<script src="/ecs/js/FBXLoader.js"></script>
		<script src="/ecs/js/VirtualInput.js"></script>
		<script src="/ecs/js/EditorControls.js"></script>
		<script src="/ecs/js/SubdivisionModifier.js"></script>
		<script src="/ecs/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

		<script src="/ecs/js/KeyboardState.js"></script>
		<script src="/ecs/engine/Enviroment.js"></script>
		<script src="/ecs/engine/pre-alpha/Entity.js"></script>
		<script src="/ecs/engine/pre-alpha/EntityManager.js"></script>

		<script>

		//	Global helpers.

			Number.prototype.format = function (){
				return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
			};

		//	save_file.js
			function saveString( text, filename ) {
				save( new Blob( [ text ], { type: "text/plain" } ), filename );
			}

			function saveArrayBuffer( buffer, filename ) {
				save( new Blob( [ buffer ], { type: "application/octet-stream" } ), filename );
			}

			function save( blob, filename ) {

				var link = document.createElement( "a" );
				link.href = URL.createObjectURL( blob );
				link.download = filename || "untitled";
				link.click();

			}

		//	round.js
			function round(number, precision) {
				var shift = function (number, precision, reverseShift) {
					if (reverseShift) {
						precision = -precision;
					}  
					numArray = ("" + number).split("e");
					return +(numArray[0] + "e" + (numArray[1] ? (+numArray[1] + precision) : precision));
				};
				return shift(Math.round(shift(number, precision, false)), precision, true);
			}

		//	array_move.js
			function array_move( arr, old_index, new_index ){

				if (new_index >= arr.length) {
					var k = new_index - arr.length + 1;
					while (k--) {
						arr.push(undefined);
					}
				}

				arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
			}

		//	deep_copy.js
			function deepCopy(obj) {
				if (Object.prototype.toString.call(obj) === "[object Array]") {
					var out = [], i = 0, len = obj.length;
					for ( ; i < len; i++ ) {
						out[i] = arguments.callee(obj[i]);
					}
				//	console.log("out:", out);
					return out;
				}
				if (typeof obj === "object") {
					var out = {}, i;
					for ( i in obj ) {
						out[i] = arguments.callee(obj[i]);
					}
				//	console.log("out:", out);
					return out;
				}
				return obj;
			}

			function copyObject(obj) {

			//	1. copy has same prototype as orig
				var copy = Object.create(Object.getPrototypeOf(obj));

			//	2. copy has all of orig’s properties
				copyOwnPropertiesFrom(copy, obj);

				return copy; // warning: shallow copy!

			//	The properties are copied from orig to copy via this function:

				function copyOwnPropertiesFrom(target, source) {
					Object.getOwnPropertyNames(source).forEach(function(propKey) { // [1][2]
						var desc = Object.getOwnPropertyDescriptor(source, propKey); // [3]
						Object.defineProperty(target, propKey, desc); // [4]
					});
					return target;
				};

			}

		//	## Copying an Object
		//	source: "http://speakingjs.com/es5/ch17.html#private_data_for_objects".
		//	To create an identical copy of an object, you need to get two things right:
		//	The copy must have the same prototype as the original.
		//	The copy must have the same properties, with the same attributes as the original.
		//	The following function performs such a copy:
		//
		//	These are the steps involved:
		//	[1] Get an array with the keys of all own properties of source.
		//	[2] Iterate over those keys.
		//	[3] Retrieve a property descriptor.
		//	[4] Use that property descriptor to create an own property in target.

		</script>

		<script>

		//	TabUI.js

			(function(){

				var sidePanel = createSidePanel();
				var loginTab = TabUI.add( "Login", "login-tab" );
				var debugTab = TabUI.add( "Debug", "debug-tab" );
				var levelTab = TabUI.add( "Levels", "level-tab" );
				var cameraTab = TabUI.add( "Camera", "camera-tab" );
				var controlTab = TabUI.add( "Controls", "control-tab" );
				var materialTab = TabUI.add( "Material", "material-tab" );
				var animationTab = TabUI.add( "Animations", "animation-tab" );
				var pathfinderTab = TabUI.add( "Pathfinder", "pathfinder-tab" );

				document.body.appendChild( sidePanel );
				TabUI.append("Animations", "Debug" );
				TabUI.Animations.role.classList.add("active");
				TabUI.Animations.tab.classList.add("in","active");

			})();

		</script>

		<script>
/*
		//	Enity Component System Engine.

		//	## Entities.
		//	(A unique ID that tags each object as a separate item. 
		//	Implementations typically use a plain integer for this).
		//
		//	Entities are objects with an id. 
		//	Entities contains components. They are component containers.
		//	We add/remove components in an entity to define the "kind" of this entity.
		//	All values of all components of an entity defines the "state" of this entity.
		//	An entity can be at least one or more entity "kinds".
		//	Entity "kinds" can modified from systems by adding/removing components.
		//	Entities are parsed to systems.
		//	(entity) kind:  Entities do not know what "kind" they are.
		//	(entity) state: Entities do not know what "state" they are.
		//	System: Entities do not know which systems use them. 
		//	Component: Entities do not know what components they contain.
		//	Speaking with mongodb terms, entity is a document: the id of the document 
		//	is the entity id and the fields of the document are the components.
		//	All entities are members of the Entity class.
		//
		//	## Components.
		//	(Implementations typically use structs[1], classes[2], or associative arrays[3]).
		//
		//	"Component" is used to mean both the template/OOP class that holds the data, 
		//	and the individual instances of that template/class. When this is unclear, 
		//	we usually say "Component-Type" to mean the class, and "Component Instance" 
		//	to mean a single instance attached to a specific Entity.
		//
		//	Components are objects with data. They are data containers. 
		//	Components are a piece of data. All data exists inside components (component intialition).
		//	Components are added/removed to entities to define the "kind" of an entity (entity initialition).
		//	The values (data) of this component define the "state" of this component in this entity.
		//	The values (data) of each component of an entity defines a part of the "state" of this entity.
		//	The population of all components in an entity defines the "kinds" of this entity.
		//	The constructors of all components in an entity defines the "kind" of this entity.
		//	Components values (data) are modified by systems. 
		//	There are none or more systems that modify this component values (data).
		//	Components can be shared by many entities.
		//	Components do not know which entity contains them.
		//	Components do not know what system modify them.
		//	Components do not know what "state" they are.
		//	Components do not know each other in an entity.
		//	All components are members of the Component super class.
		//
		//	Extend Component super class with Object3D child class (traditional js).
		//	source: "https://medium.com/beginners-guide-to-mobile-web-development/super-and-extends-in-javascript-es6-understanding-the-tough-parts-6120372d3420"
		//
		//		function Object3D(name, data) {
		//			Component.call(this, name, data);
		//		}
		//
		//		Object3D.prototype = Object.create(Component.prototype);
		//		Object3D.prototype.constructor = Object3D;
		//		Object3D.prototype.isComponent = Component.prototype.isComponent;
		//		Object3D.prototype.set = function( key, value ){
		//			Component.prototype.set.call(this, key, value);
		//		};
		//		Object3D.prototype.get = function( key ){
		//			Component.prototype.get.call(this, key);
		//		};
		//
		//	## Systems.
		//
		//	(All the code for the one aspect of the gameobjects, with each System running continuously as 
		//	if it has a private internal thread, performing global actions on every Entity that possesses 
		//	a Component of the same aspect as that System).
		//
		//	Originally, is recommended developers to start with "1 component-type per 1 System", 
		//	but real-world projects rarely stick to this, often having multiple Component-types 
		//	for a single System — and multiple Systems sharing individual Component-types.
		//
		//	System are functions that execute a piece of logic. All logic included in system's code (processors).
		//	System accept [arrays of entities] and modify some values (data) of some components of each entity.
		//	A system proccess only specific "kind" of entities (that contain specific components).
		//	System modify the values (data) of components (changes the "state" of components).
		//	System modify the values (data) of components (changes the "state" of the entity).
		//	System can add/remove components from an entity (change the "kind" of the entity).
		//	Systems are triggered by events, by signals, by observers, or runs continuously.
		//	All systems are members of the System super class.
		//
		//	System super class.
		//
		//	function System ( entities ){}
		//	System.prototype.isSystem = true;
		//
		//	Example: Extend System super class with ChildSystem child class (traditional js).
		//	source: "https://medium.com/beginners-guide-to-mobile-web-development/super-and-extends-in-javascript-es6-understanding-the-tough-parts-6120372d3420"
		//
		//		function ChildSystem ( entities ){
		//			System.call(this, entities);
		//		}
		//
		//		ChildSystem.prototype = Object.create(System.prototype);
		//		ChildSystem.prototype.constructor = ChildSystem;
		//		ChildSystem.prototype.isSystem = System.prototype.isSystem;
		//
		//	Notes:
		//
		//	[1] Using structs in JavaScript (example, syntax):  I like the idea of using something like a C-like “struct” 
		//	in my JavaScript code, so I used the following approach on a recent project. I define my JavaScript struct:
		//
		//		function BookStruct(title, href, imageUri, description) {
		//			this.title = title;
		//			this.href = href;
		//			this.imageUri = imageUri;
		//			this.description = description;
		//		}
		//
		//	[2] Classes in JavaScript are a special syntax for its prototypical inheritance model that is a comparable 
		//	inheritance in class-based object oriented languages. Classes are just special functions added to ES6 that 
		//	are meant to mimic the class keyword from these other languages. In JavaScript, we can have class declarations 
		//	and class expressions, because they are just functions. So like all other functions, there are function 
		//	declarations and function expressions. Classes serve as templates to create new objects.
		//	Classes always use strict. All code inside the class construct is automatically in strict mode.
		//
		//		class Person{
		//			constructor(firstName, lastName) {
		//				this.firstName= firstName;
		//				this.lastName = lastName;
		//			}
		//		}
		//
		//	JavaScript classes initialize instances with constructors, define fields and methods. You can attach fields 
		//	and methods even on the class itself using the "static" keyword. Inheritance is achieved using "extends" keyword: 
		//	you can easily create a child class from a parent. "super" keyword is used to access the parent class from a 
		//	child class. To take advantage of encapsulation, make the fields and methods private to hide the internal 
		//	details of your classes. The private fields and methods names must begin with #.
		//			
		//	[3] Associative Array in JavaScript: Associative arrays are dynamic objects that the user redefines as needed. 
		//  When you assign values to keys in a variable of type Array, the array is transformed into an object, and it 
		//	loses the attributes and methods of Array. The length attribute has no effect because the variable is not longer 
		//	of Array type.
*/
		</script>

		<script>

		//	# A Python ECS Implementation.
		//	source: "https://github.com/seanfisk/ecs"
		//	An MIT-licensed Python entity/component system library for games. http://ecs.rtfd.org
		//
		//	There are many articles on the Internet advocating a switch to entity-based systems for game logic. 
		//	However, many authors seem to burn themselves out telling why the old inheritance-based approach is 
		//	problematic and how an entity system will solve your problems — without ever really explaining what 
		//	it is or how to do it. This project attempts to provide an actual implementation for use in real games.
		//	The library is called an "entity/component system" library rather than an "entity system," 
		//	as the entity portion is just one building block of the total concept.
		//	Inspiration is taken from the Ash framework for ActionScript 3.0 and Artemis framework for Java.
		//
		//	## Concepts
		//
		//	ECS stands for Entity, Component, and System. Each of these parts is important. So what are these?
		//	Entity: Simply a unique identifier, used to label components as belonging to a logical grouping.
		//	Component: A collection of data. Has no behavior associated with it.
		//	System: Piece of code to operate on data in components for a single frame.
		//
		//	## Details
		//
		//	ECS defines a few core core classes:
		//	Entity, Component, System, EntityManager, SystemManager.
		//
		//	The Entity class is simply a representation of a unique identifier, and is not to be subclassed. 
		//	The Component class is intended to be subclassed for your custom components. 
		//	System is also intended to be subclassed for your custom systems.
		//
		//	The EntityManager is a database that stores Component subclasses, referenced by their type and entity ID. 
		//	The SystemManager maintains a set of System instances and allows them to perform their operations.
		//
		//	The real action happens in the update() method of your subclassed System classes. 
		//	A System instance queries the EntityManager database for a set of Component subclasses 
		//	and operates on the data contained in them.
		//
		//	## Description
		//
		//	A system that maintains the state of the game as a database like structure.
		//	The data stored is encapsulated in "Components", which have only data-members.
		//	The interface of the various parts is defined below.
		//
		//	EntityManager {
		//
		//		addComponent(entity_id, component_instance)
		//			Adds a component object to the database, associated with the entity_id
		//
		//		removeComponent(entity_id, component_type)
		//			Removes a component object from the database if the entity_id has such a component.
		//			Does not do any kind of data tear-down. This method simply makes that component
		//			unavailable from the database.
		//
		//		getPairs(component_type)
		//			Returns a list of pairs of entity_id's and components for a given component type.
		//			Alleviates the need of doing a reverse look-up to get the id of an entity with
		//			a certain kind of component.
		//
		//		getComponentForEntity(entity_id, component_type)
		//			Returns the component_type component for the given entity_id. Returns None if there
		//			is no component of that type associated with that id.
		//
		//	}
		//
		//
		//	Entity {
		//
		//		guid
		//
		//	}
		//
		//	A unique number that identifies this identity.
		//	The entity class is simply a way to logically encapsulate an identifier.
		//
		//
		//	Component {
		//
		//		data1
		//		data2
		//		data3
		//
		//	}
		//
		//	Arbitrary data members. May contain a custom initializer but should not
		//	have any other methods, especially any that modify state beyond simple getters/setters
		//	with validation. Might be good to define factory methods at the class level 
		//	for each component type.
		//
		//
		//	All of these types are used by a separate set of classes called "Systems".  
		//	Systems are bits of code that operate on items from the EntityManager database.
		//
		//	System {
		//
		//		update(dt, entity_manager)
		//			Called every frame by the SystemManager.
		//			The system can query the database for components and operate on them.
		//			This is where the logic of the game is implemented.
		//
		//	}
		//
		//	Each System subclass is responsible for a narrow set of operations. 
		//	Should only do the minimum necessary to make a certain feature work.
		//	No persistent references should be made to things from the database 
		//	unless you have	a really, really good reason. 
		//	Things are likely to come and go from the database.
		//
		//
		//	SystemManager {
		//
		//		initializer(entity_manager)
		//			Creates a new SystemManager.  Requires a reference to an EntityManager so that the systems 
		//			can get the required components.
		//
		//		addSystem(system_instance, priority)
		//			Adds a system instance to the manager.  It will be updated according the priority passed in.
		//			Will throw an Error if a system of that type is already present.
		//
		//		removeSystem(system_type)
		//			Removes a given system type from the manager.
		//
		//		update(dt)
		//			The SystemManager goes through its list of Systems and calls their update methods.
		//			The list is sorted so systems get updated in their intended priority.
		//			This method is called externally by the game-loop machinery.
		//
		//	}
		//
		//
		//	## Database format:
		//
		//	Indexable by comp_type:
		//
		//	d = {
		//		comp_type_1 : {
		//			id_1 : comp_instance_1,
		//			id_2 : comp_instance_2
		//		},
		//		comp_type_2 : {
		//			id_1 : comp_instance_3,
		//			id_2 : comp_instance_4
		//		},
		//	}
		//
		//	So to get all components of a certain type, it's simply:
		//
		//	all_comps = d[comp_type].values()
		//
		//	To get the comp for an entity,
		//
		//		comp_1 = d[comp_type][entity_id]
		//
		//	Both types of access are pretty fast and shouldn't cause any speed problems.
		//
		//
		//	## Further Reading
		//
		//	Entity/component systems are a relatively new concept. The canonical source for all entity system-related 
		//	topics is the Entity Systems wiki, created by Adam Martin. Adam Martin has also written abundantly in his 
		//	series of posts about Entity Systems, which are a great read for those just getting familiar with the concept.

		</script>

		<script>

		//	[1] JavaScript provides six primitive types as "undefined", "null", 
		//	"boolean", "number", "string", and "symbol", and a reference type "object".
		//
		//	[2] The "new" keyword performs following tasks:
		//	source: "https://www.tutorialsteacher.com/javascript/new-keyword-in-javascript"
		//
		//	1. It creates new empty object e.g. obj = { };
		//	2. It sets new empty object's invisible 'prototype' property to be the constructor function's 
		//	visible and accessible 'prototype' property. (Every function has visible 'prototype' property 
		//	whereas every object includes invisible 'prototype' property)
		//	3. It binds property or function which is declared with this keyword to the new object.
		//	4. It returns newly created object unless the constructor function returns a non-primitive value 
		//	(custom JavaScript object). If constructor function does not include return statement then compiler 
		//	will insert 'return this;' implicitly at the end of the function. If the constructor function returns 
		//	a primitive value then it will be ignored.
		//
		//	The "new" keyword ignores return statement that returns primitive value.
		//	If function returns non-primitive value (custom object) then "new" keyword 
		//	does not perform the above 4 tasks.
		//	Thus, "new" keyword builds an object of a function in JavaScript.
		//
		//	When comparing two objects, you need to be more careful. They are compared by their identity. 
		//	That means it does not matter if the two objects have the same properties with the same values. 
		//	They are equal only if they are the same instance. That is - if comparing two variables, 
		//	they are equal only if they point to the very same object.

		</script>

		<script>
/*
			const KeyboardState = function(){

			//	to store the current state
				this.keyCodes = {};
				this.modifiers = {};

			//	create callback to bind/unbind keyboard events
				var self = this;
				this._onKeyDown	= function(event){ self._onKeyChange(event, true); };
				this._onKeyUp	= function(event){ self._onKeyChange(event, false);};

			//	bind keyEvents
				window.addEventListener("keydown", this._onKeyDown, false);
				window.addEventListener("keyup", this._onKeyUp, false);
			}

			KeyboardState.prototype.destroy	= function(){
			//	unbind keyEvents
				window.removeEventListener("keydown", this._onKeyDown, false);
				window.removeEventListener("keyup", this._onKeyUp, false);
			}

			KeyboardState.MODIFIERS	= ['shift', 'ctrl', 'alt', 'meta'];
			KeyboardState.ALIAS	= {
				'left'		: 37,
				'up'		: 38,
				'right'		: 39,
				'down'		: 40,
				'space'		: 32,
				'pageup'	: 33,
				'pagedown'	: 34,
				'tab'		: 9
			};

			KeyboardState.prototype._onKeyChange = function(event, pressed){
			//	debugMode && console.log("onKeyChange", event, pressed, 
			//	event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey);

			//	update this.keyCodes.
				var keyCode = event.keyCode;
				this.keyCodes[keyCode] = pressed;

			//	update this.modifiers.
				this.modifiers['shift'] = event.shiftKey;
				this.modifiers['ctrl']	= event.ctrlKey;
				this.modifiers['alt']	= event.altKey;
				this.modifiers['meta']	= event.metaKey;
			};

			KeyboardState.prototype.pressed	= function(keyDesc){
				var keys = keyDesc.split("+");
				for (var i = 0; i < keys.length; i++){
					var pressed, key = keys[i];
					if( KeyboardState.MODIFIERS.indexOf( key ) !== -1 ){
						pressed	= this.modifiers[key];
					} else if ( Object.keys(KeyboardState.ALIAS).indexOf( key ) != -1 ){
						pressed	= this.keyCodes[ KeyboardState.ALIAS[key] ];
					} else {
						pressed	= this.keyCodes[key.toUpperCase().charCodeAt(0)]
					}
					if( !pressed) return false;
				};
				return true;
			};
*/
		</script>

		<script>

		//	System helpers.

			function systemValidator(components){
				while( components.length ){
					if ( components.shift() === undefined ) return false;
				}
				return true;
			}
			
			function systemCheckLog(_id, system, passed, components){
				debugMode && console.log("Check:", {
					"_id": _id,
					"system": system, 
					"passed": passed,
					"components": components
				});
			}

		//	System debug helpers.
			
			function syslogcid( name, array ){ 
				if (array.length) return name+":["+array.join()+"]"; 
			}

		</script>

		<script>

		//	Singals.js

			const Signal = signals.Signal;

		</script>

		<script>

		//	## Application State Class.

			const StateManager = function(){};

			StateManager.prototype.INIT = true;
			StateManager.prototype.STOP = false;
			StateManager.prototype.TEAR = false;
			StateManager.prototype.START = false;
			StateManager.prototype.PAUSE = false;
			StateManager.prototype.UPDATE = false;

			StateManager.prototype.debugMode = true;
			StateManager.prototype.editorMode = false;
			StateManager.prototype.isScaling = false;
			StateManager.prototype.isRotating = false;
			StateManager.prototype.isTranslating = false;

			StateManager.prototype.update = function(){
				debugMode = this.debugMode;
				editorMode = this.editorMode;
				isScaling = this.isScaling;
				isRotating = this.isRotating;
				isTranslating = this.isTranslating;
			};

			StateManager.prototype.update();

		</script>

		<script>

		//	## System Manager Class (under construction).

		//	System manager fires the systems on runtime.
		//	System manager define the order that systems will fired.
		//	System manager fires the systems for "init", "update"
		//	and "render" state. It also fires the systems of every
		//	"event", "signal" or watched observers.

			function SystemManager(){};

		//	requestFrameId.
			SystemManager.prototype.requestFrameId = 0;
			SystemManager.prototype.isSystemManager = true;

		//	KeyboardState.
			SystemManager.keyboard = new KeyboardState(); // important! (non-prototype)
			SystemManager.keyboard.frontAngle = 0;

			window.addEventListener("keyup", updateKeyboardFrontAngle );
			window.addEventListener("keydown", updateKeyboardFrontAngle );
			window.addEventListener("keyup", updateKeyboardVerticalAngle );
			window.addEventListener("keydown", updateKeyboardVerticalAngle );

			function updateKeyboardFrontAngle(){

				var rad = Math.PI/4;
				var keyboard = SystemManager.keyboard; 

				var UP     = keyboard.pressed("W") || keyboard.pressed("up");
				var LEFT   = keyboard.pressed("A") || keyboard.pressed("left");
				var DOWN   = keyboard.pressed("S") || keyboard.pressed("down");
				var RIGHT  = keyboard.pressed("D") || keyboard.pressed("right");

			//	debugMode && console.log( UP, LEFT, DOWN, RIGHT );

					 if (  UP && !LEFT && !DOWN && !RIGHT ) keyboard.frontAngle = 0 * rad; //   0 deg.
				else if (  UP &&  LEFT && !DOWN && !RIGHT ) keyboard.frontAngle = 1 * rad; //  45 deg.
				else if ( !UP &&  LEFT && !DOWN && !RIGHT ) keyboard.frontAngle = 2 * rad; //  90 deg.
				else if ( !UP &&  LEFT &&  DOWN && !RIGHT ) keyboard.frontAngle = 3 * rad; // 135 deg.
				else if ( !UP && !LEFT &&  DOWN && !RIGHT ) keyboard.frontAngle = 4 * rad; // 180 deg.
				else if ( !UP && !LEFT &&  DOWN &&  RIGHT ) keyboard.frontAngle = 5 * rad; // 225 deg.
				else if ( !UP && !LEFT && !DOWN &&  RIGHT ) keyboard.frontAngle = 6 * rad; // 270 deg.
				else if (  UP && !LEFT && !DOWN &&  RIGHT ) keyboard.frontAngle = 7 * rad; // 315 deg.
			//	else if ( !UP && !LEFT && !DOWN && !RIGHT ) keyboard.frontAngle = 8 * rad; // 360 deg.

			}

			function updateKeyboardVerticalAngle(){

				var rad = Math.PI/4;
				var keyboard = SystemManager.keyboard; 

				var ZENITH = keyboard.pressed("E");
				var NATHIR = keyboard.pressed("Q");

			//	debugMode && console.log( TOP, BOTTOM );

				     if ( !ZENITH && !NATHIR ) keyboard.verticalAngle =  0 * rad; //   0 deg.
				else if (  ZENITH && !NATHIR ) keyboard.verticalAngle =  2 * rad; //  90 deg.
				else if ( !ZENITH &&  NATHIR ) keyboard.verticalAngle = -2 * rad; // -90 deg.
				else if (  ZENITH &&  NATHIR ) keyboard.verticalAngle =  0 * rad; //   0 deg.

			}

		//	Init/Start/Pause/Stop/Tear events.

			SystemManager.prototype.init = function(entities){
				//	Define init systems order.
			};
			SystemManager.prototype.start = function(entities){
				//	Define start systems order.
			};
			SystemManager.prototype.pause = function(entities){
				//	Define pause systems order.
			};
			SystemManager.prototype.stop = function(entities){
				//	Define stop systems order.
			};
			SystemManager.prototype.tear = function(entities){
				//	Define tear??? systems order.
			};

		//	Camera Controls.

			SystemManager.prototype.cameraControls = (function( camera ){

				var object = new THREE.Object3D();
				
				var options = {	
					el: renderer.domElement,
					offset: new THREE.Vector3( 0, 0, 0 ), // eye height.
					radius: 2, // default distance of the character to the camera.
					minRadius: 2,
					maxRadius: 10,
					rigidObjects: [],
				};

				var cameraControls = new MW.TPSCameraControl(
					camera, 	// three.js camera.
					object,	    // tracking object.
					options
				);

				(function update(){
					requestAnimationFrame( update );
					cameraControls.update();
					cameraControls.frontAngle = cameraControls.getFrontAngle();
				})();

				return cameraControls;

			})( camera );

		//	Camera Joystick.

			SystemManager.prototype.cameraJoystick = (function( cameraControls ){

				var joystickControls = document.createElement( "div" );
				joystickControls.id = "joystick-controls-1";
				joystickControls.classList.add("joystick-controls");
				document.body.appendChild( joystickControls );

				var joystick = new virtualInput.Joystick( $( "#joystick-controls-1" ), 94, { id: "joystick1" } );

				joystick.update = function(){

					if ( joystick.isActive ) {

						cameraControls.setLatLon(
							cameraControls.lat + joystick.position.y * 0.5, // deg.
							cameraControls.lon - joystick.position.x        // deg.
						);

					}
				};

				(function update(){
					requestAnimationFrame( update );
					joystick.update();
				})();

				return joystick;

			})( SystemManager.prototype.cameraControls );

		//	Joystick Controls.

			SystemManager.prototype.joystickControls = (function( cameraControls ){

				var joystickControls = document.createElement( "div" );
				joystickControls.id = "joystick-controls-2";
				joystickControls.classList.add("joystick-controls");
				document.body.appendChild( joystickControls );

				var joystick = new virtualInput.Joystick( $( "#joystick-controls-2" ), 94, { id: "joystick2" } );

			//	Update.

				function updateDirection( entity ){
					var rad = 3 * Math.PI/2; // 270 deg.
					var joystickAngle = joystick.angle;
					var cameraFrontAngle = cameraControls.getFrontAngle();
					entity.characterController.direction = rad - cameraFrontAngle + joystickAngle;
				}

				joystick.update = function( entity ){
					if ( !entity.joystickControls ) return;
					if ( joystick.isActive ) updateDirection( entity );
				};

			//	Bind virtualJoystick events.

				function isOnAir( entity ){
					return ( entity.characterController.isJumping 
					|| !entity.characterController.isGrounded 
					|| entity.characterController.isOnSlope );
				}

				function startRunning( entity ){
					if ( isOnAir( entity ) ) return;
					entity.characterController.isRunning = true;
				}

				function stopRunning(entity){
					if ( isOnAir( entity ) ) return;
					entity.characterController.isRunning = false;
				}

				joystick.addEventListener( "active", function(e) { 
					this.entities = entities.filter(function( entity ){
						return !!entity.joystickControls && !!entity.characterController;
					});
					for (var i = 0; i < this.entities.length; i++ ){
						startRunning( this.entities[i] );
					}
				});

				joystick.addEventListener( "disactive", function(e) { 
					this.entities = entities.filter(function( entity ){
						return !!entity.joystickControls && !!entity.characterController;
					});
					for (var i = 0; i < this.entities.length; i++ ){
						stopRunning( this.entities[i] );
					}
				});

				return joystick;

			})( SystemManager.prototype.cameraControls );

		//	Jumb Button.

			SystemManager.prototype.jumpButton = (function(){

				var interval;
				var button = new virtualInput.Button( $( "#joystick-controls-1" ), 58, { id: "jumpButton", label: "<b>JUMP</b>" } );

			//	Use clearTimeout to event listeners to ensure last event parsing.
			//	Because "press" event fires twice, we use the clearTimeout method 
			//	to parse only the last "press" event.

				function startJumping( entity ){
					entity.characterController.jump();
				}

				button.addEventListener( "press", function(e) {
				//	debugMode && console.log(e); // double event.

					clearTimeout( interval );
					interval = setTimeout(function(){
					//	debugMode && console.log(e); // single event.

						button.entities = entities.filter(function( entity ){
							return !!entity.joystickControls && !!entity.characterController;
						});

						for (var i = 0; i < button.entities.length; i++ ){
							startJumping( button.entities[i] );
						}

					});
				});

				return button;

			})();

		//	Key Input Controls.

			SystemManager.prototype.keyInputControls = (function( cameraControls ){
				
				var keyInputControls = new MW.KeyInputControl();

			//	KeyInputControl events.

				function startJumping( entity ){
					entity.characterController.jump();
				}

				function startRunning( entity ){
					entity.characterController.isRunning = true;
				}

				function stopRunning( entity ){
					entity.characterController.isRunning = false;
				}

				function updateDirection( entity ){
					var rad = 2 * Math.PI; // THREE.Math.degToRad( 360 );
					var cameraFrontAngle = cameraControls.getFrontAngle();
					var keyInputFrontAngle = keyInputControls.frontAngle;
					entity.characterController.direction = rad - cameraFrontAngle + keyInputFrontAngle;
				}

				keyInputControls.addEventListener( "movekeyon", function (e) { 
					this.entities = entities.filter(function( entity ){
						return !!entity.keyInputControls && !!entity.characterController;
					});
					for (var i = 0; i < this.entities.length; i++ ){
						startRunning( this.entities[i] );
						updateDirection( this.entities[i] );
					}
				});

				keyInputControls.addEventListener( "movekeyoff", function (e) { 
					this.entities = entities.filter(function( entity ){
						return !!entity.keyInputControls && !!entity.characterController;
					});
					for (var i = 0; i < this.entities.length; i++ ){
						stopRunning( this.entities[i] );
						updateDirection( this.entities[i] );
					}
				});

			//	Synch keyInput and camera controls.
				keyInputControls.addEventListener( "movekeychange",  function (e) {
					this.entities = entities.filter(function( entity ){
						return !!entity.keyInputControls && !!entity.characterController;
					});
					for (var i = 0; i < this.entities.length; i++ ){
						updateDirection( this.entities[i] );
					}
				});

				keyInputControls.addEventListener( "jumpkeypress", function (e) { 
					this.entities = entities.filter(function( entity ){
						return !!entity.keyInputControls && !!entity.characterController;
					});
					for (var i = 0; i < this.entities.length; i++ ){
						startJumping( this.entities[i] );
					}
				});

				return keyInputControls;

			})( SystemManager.prototype.cameraControls );

		//	Keyboard events.

			SystemManager.prototype.keyup = function(e, entities){};
			SystemManager.prototype.keydown = function(e, entities){};
			SystemManager.prototype.keypress = function(e, entities){};

		//	Mouse events.

			SystemManager.prototype.click = function(e, entities){};
			SystemManager.prototype.contextmenu = function(e, entities){};
			SystemManager.prototype.dbclick = function(e, entities){};
			SystemManager.prototype.mousedown = function(e, entities){};
			SystemManager.prototype.mouseenter = function(e, entities){};
			SystemManager.prototype.mouseleave = function(e, entities){};

			SystemManager.prototype.mousemove = function(e){
			//	debugMode && console.log( e );
			//	if ( e.type != "mousemove" ) return;
			//	Define mousemove event systems order.
			//	MouseMoveSystemEventHandler(e, entities);
			};

			SystemManager.prototype.mouseout = function(e, entities){};
			SystemManager.prototype.mouseover = function(e, entities){};
			SystemManager.prototype.mouseup = function(e, entities){};

		//	Drag events.

			SystemManager.prototype.drag = function(e){
			//	debugMode && console.log( e );
			//	if ( e.type != "drag" ) return;
			//	Define drag event systems order.
			//	CameraLightUpdateSystem(entities);

			};

			SystemManager.prototype.dragenter = function(e, entities){};
			SystemManager.prototype.dragover = function(e, entities){};
			SystemManager.prototype.dragstart = function(e, entities){};
			SystemManager.prototype.dragend = function(e, entities){};
			SystemManager.prototype.dragleave = function(e, entities){};
			SystemManager.prototype.drop = function(e, entities){};

		//	Touch events.

			SystemManager.prototype.touchstart = function(e, entities){};
			SystemManager.prototype.touchmove = function(e, entities){};
			SystemManager.prototype.touchend = function(e, entities){};
			SystemManager.prototype.touchcancel = function(e, entities){};

		//	EventObject events.

			SystemManager.prototype.abort = function(e, entities){};
			SystemManager.prototype.load = function(e, entities){};
			SystemManager.prototype.change = function(e, entities){};
			SystemManager.prototype.error = function(e, entities){};
			SystemManager.prototype.input = function(e, entities){};
			SystemManager.prototype.message = function(e, entities){};
			SystemManager.prototype.online = function(e, entities){};
			SystemManager.prototype.offline = function(e, entities){};
			SystemManager.prototype.open = function(e, entities){};
			SystemManager.prototype.pause = function(e, entities){};
			SystemManager.prototype.play = function(e, entities){};
			SystemManager.prototype.scroll = function(e, entities){};
			SystemManager.prototype.select = function(e, entities){};
			SystemManager.prototype.submit = function(e, entities){};
			SystemManager.prototype.beforeunload = function(e, entities){};
			SystemManager.prototype.unload = function(e, entities){};
			SystemManager.prototype.progress = function(e, entities){};

			SystemManager.prototype.resize = function(e){
			//	debugMode && console.log( e );
			//	if ( e.type != "resize" ) return;
			//	Define resize event systems order.
			//	WindowResizeSystemEventHandler(entities);

			};

		//	Intervals.

			SystemManager.prototype.timeout = function(entities){
				//	Define timeout systems order.
			}

			SystemManager.prototype.interval = function(entities){
				//	Define interval systems order.
			}

		//	Updates.

			SystemManager.prototype.update = function(entities){
			//	Define updating systems order.
				for (var i = 0; i < entities.length; i++ ){

				//	Update direction.
					if ( entities[i].characterController ) (function(entity){
						SystemManager.prototype.joystickControls.update( entity );
					})( entities[i] );

				//	Update rotation.y
					if ( entities[i].characterController ) (function(entity){
						var object = entity.characterController.object;
						var controller = entity.characterController;
						object.rotation.y = controller.direction + Math.PI; // important!
					})( entities[i] );

				//	Keep object on ground.
					if ( entities[i].characterController ) (function(entity){
						var object = entity.characterController.object;
						var controller = entity.characterController;
						object.position.y = controller.center.y - controller.radius;
					})( entities[i] );

				}
			};

			SystemManager.prototype.render = function(entities){};

		//	Runtime.

			SystemManager.prototype.runtime = function(){

			//	var system_manager = this;

				var INIT = StateManager.prototype.INIT;
				var TEAR = StateManager.prototype.TEAR;
				var STOP = StateManager.prototype.STOP;
				var START = StateManager.prototype.START;
				var PAUSE = StateManager.prototype.PAUSE;
				var UPDATE = StateManager.prototype.UPDATE;

				if ( INIT ) {
					SystemManager.prototype.init(entities);
					INIT = false; 
					START = true;
				} else if ( START ) {
					SystemManager.prototype.start(entities);
					START = false; 
					UPDATE = true;
				}

			//	SystemManager.prototype.pause(entities);
			//	SystemManager.prototype.stop(entities);
			//	SystemManager.prototype.tear(entities);

				(function runtime(){

				//	var dt = clock.getDelta();
				//	var elapsed = clock.getElapsedTime();
					SystemManager.prototype.requestFrameId = requestAnimationFrame( runtime );

					if ( START ) { UPDATE = true;  PAUSE = false; STOP  = false; }
					if ( PAUSE ) { UPDATE = false; START = false; STOP  = false; }
					if ( STOP  ) { UPDATE = false; PAUSE = false; START = false; }
					if ( UPDATE) { START  = false; PAUSE = false; STOP  = false  }
				//	cancelAnimationFrame( SystemManager.prototype.requestFrameId );
					if ( !INIT && !START && !PAUSE && !STOP && !TEAR ) UPDATE = true;

					if ( UPDATE ) {
						SystemManager.prototype.update(entities);
					} else if ( START ) {
						SystemManager.prototype.start(entities);
						START = false;
					} else if ( PAUSE ) {
						SystemManager.prototype.pause(entities);
					} else if ( STOP  ) {
						SystemManager.prototype.stop(entities);
					} else if ( TEAR ) {
						SystemManager.prototype.tear(entities);
					}

					StateManager.prototype.update(entities);
				//	StateManager.prototype.render(entities);

				})();
			
			};

		</script>

		<script>

		//	## Understanding Component-Entity-Systems.
		//	"https://www.gamedev.net/tutorials/_/technical/game-programming/understanding-component-entity-systems-r3013"

		//	## The Component.
		//	A component can be likened to a C struct. It has no methods and is only capable of storing data, 
		//	not acting upon it. In a typical implementation, each different component type will derive from 
		//	an abstract Component class, which provides facilities for getting a component's type and containing 
		//	entity at runtime. Each component describes a certain aspect of an entity and its parameters. 
		//	By themselves, components are practically meaningless, but when used in conjunction with entities 
		//	and systems, they become extremely powerful. Empty components are useful for tagging entities.

		//	Examples:
			//	Position (x, y)
			//	Velocity (x, y)
			//	Physics (body)
			//	Sprite (images, animations)
			//	Health (value)
			//	Character (name, level)
			//	Player (empty)

		//	## The Entity.
		//	An entity is something that exists in your game world. Again, an entity is little more than 
		//	a list of components. Because they are so simple, most implementations won't define an entity 
		//	as a concrete piece of data. Instead, an entity is a unique ID, and all components that make 
		//	up an entity will be tagged with that ID. The entity is an implicit aggregation of the components 
		//	tagged with its ID. If you want, you can allow components to be dynamically added to and removed 
		//	from entities. This allows you to "mutate" entities on the fly. For example, you could have a 
		//	spell that makes its target freeze. To do this, you could simply remove the Velocity component.

		//	Examples:
			//	Rock (Position, Sprite)
			//	Crate (Position, Sprite, Health)
			//	Sign (Position, Sprite, Text)
			//	Ball (Position, Velocity, Physics, Sprite)
			//	Enemy (Position, Velocity, Sprite, Character, Input, AI)
			//	Player (Position, Velocity, Sprite, Character, Input, Player)

		//	## The System.
		//	Notice that I've neglected to mention any form of game logic. This is the job of the systems. 
		//	A system operates on related groups of components, i.e. components that belong to the same entity. 
		//	For example, the character movement system might operate on a Position, a Velocity, a Collider, 
		//	and an Input. Each system will be updated once per frame in a logical order. 
		//	To make a character jump, first the keyJump field of the Input data is checked. If it is true, 
		//	the system will look through the contacts contained in the Collider data and check if there is 
		//	one with the ground. If so, it will set the Velocity's y field to make the character jump. 
		//	Because a system only operates on components if the whole group is present, components implicitly 
		//	define the behaviour an entity will have. For example, an entity with a Position component but not 
		//	a Velocity component will be static. Since the Movement system uses a Position and a Velocity, 
		//	it won't operate on the Position contained within that entity. Adding a Velocity component will 
		//	make the Movement system work on that entity, thus making the entity dynamic and affected by gravity. 
		//	This behaviour can be exploited with "tag components" (explained above) to reuse components in different 
		//	contexts. For example, the Input component defines generic flags for jumping, moving, and shooting. 
		//	Adding an empty Player component will tag the entity for the PlayerControl system so that the Input 
		//	data will be populated based on controller inputs.

		//	Examples:
			//	Movement (Position, Velocity) - Adds velocity to position
			//	Gravity (Velocity) - Accelerates velocity due to gravity
			//	Render (Position, Sprite) - Draws sprites
			//	PlayerControl (Input, Player) - Sets the player-controlled entity's input according to a controller
			//	BotControl (Input, AI) - Sets a bot-controlled entity's input according to an AI agent

		//	Conclusion
		//	To wrap up, OOP-based entity hierarchies need to be left behind in favour of Component-Entity-Systems. 
		//	Entities are your game objects, which are implicitly defined by a collection of components. 
		//	These components are pure data and are operated on in functional groups by the systems. 
		//	I hope I've managed to help you to understand how Component-Entity-Systems work, and to convince you 
		//	that they are better than traditional OOP. If you have any questions about the article, 
		//	I'd appreciate a comment or message. A follow-up article has been posted, which provides a sample 
		//	C implementation and solves some design problems. Implementing Component-Entity-Systems

		// 	Read also: "https://www.gamedev.net/tutorials/_/technical/game-programming/implementing-component-entity-systems-r3382"

		</script>

		<script>

			const keyboard = SystemManager.keyboard;

		//	Selected.
		//	Selected component is a boolean flag-component that allow 
		//	to a system to trigger and operate in entity's components
		//	data. Selected component is moving from entity to entity
		//	to represent the current selected entity. Only on multi-
		//	selecting entities is allowed to exist in more than one  
		//	entities and must be removed when the entity deselected.

			const Selected = {
			//	value: always true.
			//	flag-type boolean component.
				get get(){ return true; },
				get value(){ return true; },
				get valueOf(){ return true; },
			};

		//	Axies components.
			const axies = new THREE.Vector3(1,1,1); // component-type.
			const axisX = new THREE.Vector3(1,0,0); // component-type.
			const axisY = new THREE.Vector3(0,1,0); // component-type.
			const axisZ = new THREE.Vector3(0,0,1); // component-type.

		</script>

		<script>

		//	three-quaternion-from-normal.
		//	Builds a ThreeJS quaternion from a normal vector.
		//	This is useful for getting meshes to 'point' in the direction of a vector.

		//	Usage: quat = quaternionFromNormal(normal, [quaternionTarget])
		//	Builds a quaternion from the normal (a normalized THREE.Vector3), 
		//	storing the result in quaternionTarget (a THREE.Quaternion) 
		//	or creating a new quaternion object if no target is specified.
		//	The quaternion target is returned.

		//	Example:
		//	Say we want mesh to point from A to B point.
			//	var A = new THREE.Vector3(1, 0, 0);
			//	var B = new THREE.Vector3(2, 5,-1);
		//	Get normal A->B.
			//	var normal = B.clone().sub(A).normalize();
		//	Get orientation.
			//	var quaternion = quaternionFromNormal(normal);
		//	Apply orientation to mesh.
			//	mesh.quaternion.copy(quaternion);

			function quaternionFromNormal( normal, quaternion ){

				return setDirection(normal, quaternion);

				function setDirection(normal, quaternion) {
					quaternion = quaternion || new THREE.Quaternion();
				//	vector is assumed to be normalized.
					if (normal.y > 0.99999) {
						quaternion.set(0, 0, 0, 1);
					} else if (normal.y < -0.99999) {
						quaternion.set(1, 0, 0, 0);
					} else {
						var axis = new THREE.Vector3();
						axis.set(normal.z, 0, -normal.x).normalize();
						var radians = Math.acos(normal.y);
						quaternion.setFromAxisAngle(axis, radians);
					}

					return quaternion;
				}
			}

		</script>

		<script>

		//	Camera Controls.
			const cameraControls = SystemManager.prototype.cameraControls;

		//	Camera Virtual Joystick.
			const cameraJoystick = SystemManager.prototype.cameraJoystick;

		//	Character Virtual Joystick.
			const joystickControls = SystemManager.prototype.joystickControls;

		//	Jump Button.
			const jumpButton = SystemManager.prototype.jumpButton;

		//	Key Input Controls.
			const keyInputControls = SystemManager.prototype.keyInputControls;

		//	Helpers.
			function takeCameraLight( target ){
				cameraLight.target = target;
			}

			function takeCameraControls( target, offset ){
				cameraControls.trackObject = target;
				cameraControls.offset.y = offset || 0;
			}

		</script>

		<script>

		//	"animations" is a named entity that hold all animation clips.
			const animations = new Entity(); // important!
		//	As named entity is not important to add in entities queue.
		//	entities.push( animations );

		//	Animation tab.

			(function(){

				var tab = TabUI.Animations.tab;
				var row = document.createElement("h3");
				row.textContent = "Animation";

				var select = document.createElement("select");
				select.id = "animation-droplist";
				select.style.cssText = "width:180px;color:#000;" // float:left;
					+ "border:1px solid;border-radius:4px;padding:2px 4px 4px 4px;"
					+ "font-size:20px;margin-left:10px;";

				row.appendChild( select );
				tab.appendChild( row );

			})();

			(function(){

			//	Import Animation.

				var tab = TabUI.Animations.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:10px 12px;height:35px;text-align:center;";

				var button1 = IdleButton();
				var button2 = ImportAnimationButton();

				row.appendChild( button1 );
				row.appendChild( button2 );
				tab.appendChild( row );

				function ImportAnimationButton() {

					var button = document.createElement("div");
					button.id = "import-animaton";
					button.textContent = "Import animation";
					button.style.cssText = "min-width:60%;width:180px;float:right;height:40px;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );

					var input = document.createElement("input");
					input.type = "file";
					input.style.display = "none";
					input.setAttribute("multiple", "");

					var k = 0; // important!
					input.addEventListener( "change", function(){

						var select = document.getElementById("animation-droplist");
						if ( !select ) return;

						for ( var i = 0; i < input.files.length; i++ ) {
							(function( file ){

								var filename = file.name.replace(".fbx", "");
								var extension = file.name.split( "." ).pop().toLowerCase();

								var reader = new FileReader();

								reader.addEventListener( "progress", function ( e ) {
									var size = "(" + Math.floor( e.total / 1000 ).format() + " KB)";
									var progress = Math.floor( ( e.loaded / e.total ) * 100 ) + "%";
									debugMode && console.log( "Loading", file.name, size, progress );
								});

								reader.addEventListener( "load", function ( e ) {

									var data = reader.result;
									var loader = new THREE.FBXLoader();
									var group = loader.parse( data );
								//	debugMode && console.log( group );

								//	Add animations.
									if ( !group.animations.length ) return;
									debugMode && console.log( group.animations );

								//	Each clip is a component of animations entity.
									group.animations.forEach( function( clip ){
									//	Add clip to animations entity.
										animations[ clip.uuid ] = clip;
									//	create option.
										clip.name = filename;
										var name = ++k+"."+filename;
										var option = document.createElement("option");
										option.text = name;
										option.value = clip.uuid;
										select.appendChild( option );
									});

								}, false );
								reader.readAsArrayBuffer( file );

							})( input.files[i] );
						}

					});

					button.addEventListener( "click", function(){
						
						input.value = "";
						input.click();

					});

					button.appendChild( input );
					return button;

				}

				function IdleButton(){

					var button = document.createElement("div");
					button.id = "idle-animaton";
					button.textContent = "Pause";
					button.style.cssText = "max-width:120px;width:100px;float:left;height:40px;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );

					function playIdling( entity ){
						if ( entity.animationController.currentMotionName == "idling" ) return;
						entity.animationController.play( "idling" ); 
					}

					button.addEventListener( "click", function(){
						button.entities = entities.filter(function( entity ){
							return !!entity.characterController && !!entity.animationController;
						});
						for (var i = 0; i < button.entities.length; i++ ) {
							playIdling( button.entities[i] );
						}
					});

					return button;
				}

			})();

		</script>

		<script>

		//	## Local Player entity instance.

		//	Local player is a WorldControllable-type entity instance.
		//	Local player is world-user-animate-controllable.
		//	Local player has a character controller.
		//	Local player has an animation controller.
		//	Local player takes camera and camera-light controls.

			const localPlayer = new Entity();

		//	localPlayer abstract.

			(function(){

				var radius = 0.85; // radius.

			//	localPlayer has object3d holder.
				var object = (function(){
					var object3d = new THREE.Object3D();
					object3d.position.y = 2;
					object3d.name = "localPlayer object";
					scene.add( object3d );
					return object3d;
				})();

			//	localPlayer has a bounding sphere helper.
				var boundingSphere = (function( radius ){
					var sphere = new THREE.SphereGeometry( radius, 8, 6 );
					var geometry = new THREE.EdgesGeometry( sphere );
					var material = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
					var segments = new THREE.LineSegments( geometry, material );
					segments.position.y = radius;
					segments.name = "localPlayer helper";
				//	Add helper to scene.
					object.add( segments );
					return segments;
				})( radius );

			//	localPlayer has a charecter controller.
				var characterController = (function(object, radius){
				//	Create controller.
					var controller = new MW.CharacterController(object, radius);
				//	Initialize controller.
					controller.movementSpeed = 5; // (m/fps)
					controller.maxSlopeGradient = 0.5; // important!
				//	synch with 3d model front angle.
					controller.direction += Math.PI; // important!
				//	Add controller to world (start controller update).
					world.add( controller ); // important! updating controller.
					return controller;
				})( object, radius );

			//	Take camera controls.
				takeCameraLight( object );
				takeCameraControls( object, radius );

			//	And components.
				localPlayer.holder = object;
				localPlayer.boundingSphere = boundingSphere;
				localPlayer.keyInputControls = keyInputControls;
				localPlayer.joystickControls = joystickControls;
				localPlayer.characterController = characterController;
				debugMode && console.log( "localPlayer:", localPlayer );

			//	Add entity to entities.
				entities.push( localPlayer ); // important!

			})();


		//	entity with avatar loading.

			(function(){

				var entity = new Entity();

			//	Load the animated 3D model.
				var url = "/ecs/fbx/Idle (2).fbx";
				var loader = new THREE.FBXLoader();
				loader.load( url, function( group ){

					fbx = group; // for debugging only.
				//	Group have two children:
				//	an armature and a skinned mesh.
				//	All children in group have scale 100. Fix this:
					group.traverse(function( child ){
						var s = 1; 
						if ( child.scale !== undefined ) {
							child.scale.set(s,s,s);
						}
					});

					group.position.y = 2;
					debugMode && console.log( group );

				//	Add group to scene.
					scene.add( group );

					var r = 0.85; // radius.

				//	localPlayer has a bounding sphere helper.
					var boundingSphere = (function( radius ){
						var sphere = new THREE.SphereGeometry( radius, 8, 6 );
						var geometry = new THREE.EdgesGeometry( sphere );
						var material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
						var segments = new THREE.LineSegments( geometry, material );
						segments.position.y = radius;
						segments.name = "localPlayer helper";
					//	Add helper to scene.
						group.add( segments );
						return segments;
					})( r );

				//	localPlayer has a charecter controller (not a component).
					var characterController = (function(object, radius){  // global for debuggin only.

					//	Create controller.
						var controller = new MW.CharacterController(object, radius);

					//	Initialize.
						controller.movementSpeed = 5; // (m/fps)
						controller.maxSlopeGradient = 0.5; // important!

					//	synch with 3d model front angle.
						controller.direction += Math.PI; // important!

					//	Add controller to world (start controller update).
						world.add( controller ); // important! updating controller.

					//	(function update(){
					//		requestAnimationFrame( update );
					//	//	Update rotation.
					//		object.rotation.y = controller.direction + Math.PI; // important!
					//	//	Keep object on ground.
					//		object.position.y = controller.center.y - controller.radius;
					//	})();

						return controller;
					})( group, r );

					debugMode && console.log( characterController );

				//	localPlayer has an animation controller.
					var animations = group.animations;
					group.animations[0].name = "idling";

					var animationController = (function(){ // global for debuggin only.

						var controller = new MW.AnimationController( group );
						debugMode && console.log( "animations:", Object.keys( controller.motion ).join() );

					//	Start mixer updating immidiatly when animation controller created.
					//	Not need for an animation updating system to update the animation mixer,
					//	but need an animation manager to manage which animation is currently playing. 
					//	Can be done with character controller by adding event listeners?

					//	Start animation controller mixer.
						var clock = new THREE.Clock(); // needs own clock. Why?
						(function update(){
							requestAnimationFrame( update );
							var delta = clock.getDelta();
							controller.update( delta );
						})();
						
						return controller;
					})();

					debugMode && console.log( animationController );

				//	Bind character controller animation events.
				//	All characters skinned 3d models (avatars) must have at least one "idling" animation.
					characterController.addEventListener( "startIdling",  function () { 
						debugMode && console.log( "start Idling" );
						if ( animationController.motion.idling )
							animationController.play( "idling" );
					});
					characterController.addEventListener( "startWalking",  function () { 
						debugMode && console.log( "start Walking" );
						if ( animationController.motion.running )
							animationController.play( "running" );
					});
					characterController.addEventListener( "startSliding", function () { 
						debugMode && console.log( "start Sliding" );
						if ( animationController.motion.wobbling )
							animationController.play( "wobbling" );
					});
					characterController.addEventListener( "startFalling", function () { 
						debugMode && console.log( "start Falling" );
						if ( animationController.motion.wobbling )
							animationController.play( "wobbling" );
					});
					characterController.addEventListener( "startJumping", function() { 
						debugMode && console.log( "start Jumping" );
						if ( !characterController.isRunning ) {
							if ( animationController.motion.jumpingUp )
								animationController.play( "jumpingUp" ); 
						} else {
							if ( animationController.motion.runningJump )
								animationController.play( "runningJump" );
						}
					});

				//	Skeleton Helper.

				//	localPlayer skinned mesh has a skeleton helper.
					var skeletonHelper = (function( armature ){
						var helper = new THREE.SkeletonHelper(armature);
						scene.add( helper );
						return helper;
					})( group.getObjectByName("Armature") );

				//	Take camera controls.
				//	takeCameraLight( group );
				//	takeCameraControls( group, 0.85 );

				//	And components.
					entity.holder = group;
					entity.boundingSphere = boundingSphere;
					entity.skeletonHelper = skeletonHelper;
				//	entity.keyInputControls = keyInputControls;
				//	entity.joystickControls = joystickControls;
					entity.characterController = characterController;
					entity.animationController = animationController;
					debugMode && console.log( "entity:", entity );

				//	Add entity to entities.
					entities.push( entity ); // important!

				});

			})();

		</script>

		<script>

		//	## Synopsis.
			
			//	Define component types.
			//	Create component instances.
			//	Create entities instances.
			//	Define entities systems.
			//	Define systems order in SystemManager methods.
			//	Define SystemManager methods order in runtime.

		</script>

		<script>

		//	## Runtime.

			SystemManager.prototype.runtime();

		</script>

		<script>

			//	Rdbms With Code In Systems Implementation.
			//	source: "http://entity-systems.wikidot.com/rdbms-with-code-in-systems"
			//
			//	## Concepts.
			//		(integer) Entity
			//		(enum) ComponentType
			//		(interface OR empty base-class) Component
			//		(interface OR empty base-class) System
			//		(class with implementation) EntityManager
			//
			//	## Data Classes.
			//
			//	Entity: This is a non-negative integer, and uniquely identifies an entity 
			//	within the ES. If you serialize your ES, this SHOULD be the same after serialization. 
			//	New entities have to be assigned a new, unique, integer value when they are created. 
			//	When an entity is destroyed, its integer value is freed, available for re-use.
			//
			//	ComponentType: This is needed because this ES is so simplistic it has no other way 
			//	of identifying which Component you're talking about when you're looking at a single 
			//	Entity. (richer EntitySystems MAY not need this type).
			//
			//	Component: This exists purely to make method-signatures type-safe. 
			//	We need to know that certain objects are valid instances of a "component" 
			//	(so we use this superclass to indicate that), but we also need a method that's 
			//	guaranteed to work on all those objects. (richer EntitySystems make more use of this, 
			//	and require it to be a class).
			//
			//	System: This exists purely to contain a known method-signature that your game-loop 
			//	can call once per game-tick.
			//
			//	## EntitySystem Implementation Classes.
			//
			//	Each subclass of Component: Internally, the class has the following functions:
			//	(ComponentType) getComponentType();
			//
			//	System: Just one method, that gives you a common interface to trigger each of 
			//	the systems: processOneGameTick( long previousFrameTime );
			//
			//	EntityManager: This contains:
			//	The master collections (arrays, hashmaps, whatever) that contain all the data for all the entities.
			//	Logic for creating, modifying, fetching, and deleting entities.
			//	Logic for fetching and modifying components-from-entities.
			//	Internally, the class has the following variables:
			//	LIST: all entities in existence (so it never duplicates entity-IDs!).
			//	MAP: from "Entity + ComponentType" to "concrete Component subclass".
			//	Internally, the class has the following functions:
			//	(Component) getComponent( Entity, ComponentType );
			//	(List) getAllComponentsOfType( ComponentType );
			//	(List) getAllEntitiesPossessingComponent( ComponentType );
			//	(void) addComponent( Entity, Component );
			//	(int) createEntity;
			//	void) killEntity( Entity );

		</script>


		<script>
/*
		//	Demo: editableObject is an entity instance.

			var object = (function(d){
				var box = new THREE.BoxGeometry(d,d,d,1,1,1 );
				var geometry = new THREE.EdgesGeometry( box );
				var material = new THREE.LineBasicMaterial( { color: 0xffffff } );
				var component = new THREE.LineSegments( geometry, material );
				component.isComponent = true;
				component.position.set( -2.5, 0.5, -2.5 );
				component.name = "editor controllable object";
				//	Add mesh to scene.
				scene.add( component );
				return component;
			})(1);

		//	Take Camera controls.
			setTimeout(function(){
			//	Take cameraControls important!
				cameraControls.offset.y = 0;
				cameraControls.trackObject = object; // important!
			//	Make localPlayer uncontrollable.
				localPlayer.remove("VirtualJoystick");
			}, 5000);

			var controller = new MW.CharacterController( object, 0.5 );
			controller.velocity.set(0,0,0);
			controller.movementSpeed = 10; // (m/sec);

		//	Update Position.
			controller.updatePosition = function(dt) {
				var x = this.center.x + this.velocity.x * dt;
				var y = this.center.y + this.velocity.y * dt;
				var z = this.center.z + this.velocity.z * dt;
				this.center.set(x, y, z);
			}

		//	Update Velocity.
			controller.updateVelocity = function(){
				var frontDierction = -Math.cos(controller.direction);
				var rightDierction = -Math.sin(controller.direction);
				var x = rightDierction * this.movementSpeed * this.isRunning; // x,
				var z = frontDierction * this.movementSpeed * this.isRunning; // z,
				this.velocity.set(x,0,z);
			};

		//	Controller state.
			virtualJoystick.addEventListener( "active", function onActive() { 
				
				controller.isIdling = false;
				controller.isRunning = true;
				controller.isJumping = false;
				controller.isOnSlope = false;
				controller.isGrounded = true;

			});

			virtualJoystick.addEventListener( "disactive", function onDisactive() { 

				controller.isIdling = true;
				controller.isRunning = false;
				controller.isJumping = false;
				controller.isOnSlope = false;
				controller.isGrounded = true;

			});

		//	joystick update.
			(function update(){

				var dt = clock.getDelta();
				SystemManager.prototype.requestFrameId = requestAnimationFrame( update );

				if ( virtualJoystick.isActive ){
				//	direction update.
					var rad = THREE.Math.degToRad( 270 );
					var joystickAngle = virtualJoystick.angle;
					var cameraFrontAngle = cameraControls.getFrontAngle()
					var angle = rad - cameraFrontAngle + joystickAngle;
					controller.direction = rad - cameraFrontAngle + joystickAngle;

				//	controller update.
					controller.updatePosition(0.01); // dt.
					controller.updateVelocity();

					if (SystemManager.keyboard.pressed("X")) object.rotation.x += angle * dt;
					else if (SystemManager.keyboard.pressed("C")) object.rotation.y += angle * dt;
					else if (SystemManager.keyboard.pressed("Z")) object.rotation.z += angle * dt;
					else {

					//	object rotation update.
						object.rotation.y = controller.direction;
					//	object position update.
						object.position.x = controller.center.x;
						object.position.y = controller.center.y;
						object.position.z = controller.center.z;
					//	object.position.copy(controller.center);

					}
				} 
				
			})();

*/
/*
			var editableObject = (function(){

				var entity = new Entity(); // entity instance.

			//	editor controllable object has a Mesh component.
				var object = (function(d){
					var box = new THREE.BoxGeometry(d,d,d,1,1,1 );
					var geometry = new THREE.EdgesGeometry( box );
					var material = new THREE.LineBasicMaterial( { color: 0xffffff } );
					var component = new THREE.LineSegments( geometry, material );
					component.isComponent = true;
					component.position.set( -2.5, 0.5, -2.5 );
					component.name = "editor controllable object";
				//	Add mesh to scene.
					scene.add( component );
					return component;
				})(1);

			//	Add component to entity
				entity.Object3D = object;

			//	Add components to meke entity editor controllable.
				entity.Scale = object.scale;
				entity.Position = object.position;
				entity.Rotation = object.rotation;

			//	Push entity to entities queue.
				entities.push( entity ); // important!
				debugMode && console.log( entity );

				return entity;

			})();
			setTimeout(function(){
			//	Let's try to take control of entity line segments object.
			//	First we make the localPlayer entity user-uncontrollable.
				delete localPlayer.VirtualJoystick;
				delete localPlayer.KeyInputControl;
			//	BE CAREFULL: DO NOT DELETE the localPlayer.Controller
			//	component because will be difficult to find it again.
			//	You may remove localPlayer controller from world's character pool.
				var index = world.characterPool.findIndex(function( controller ){
					return controller.object.uuid === localPlayer.Controller.object.uuid;
				}); if ( index > -1 ) world.characterPool.splice(index, 1);
			//	Now if you delete localPlayer.Controller component, it is imposible to find it again.

				var radius = 0.5; //
			//	Create a new character controller that will take control of entity line segments object.
				var controller = new MW.CharacterController( editorControllable.Object3D, radius );
			//	adjust movement speed.
				controller.movementSpeed = 2;
			//	reset controller center.
				controller.center.copy( editorControllable.Position ); controller.center.y += radius;

			//	Make entity user controllable.
				editorControllable.Controller = controller;
				editorControllable.Direction = controller.direction;
				editorControllable.VirtualJoystick = virtualJoystick; // bypass add() method.
				editorControllable.KeyInputControl = keyInputControls; // bypass add() method.

			//	Give camera controls to editorControllable line segments object.
				cameraControls.offset.y = 0;
				cameraControls.trackObject = editorControllable.Object3D;
			}, 10000);
*/
/*
			function EditorControllablePositionSystem(dt, entities){

				var system = arguments.callee.name;
				var collected = [], collectId = [];

				for (var i = 0; i < entities.length; i++){
					var entity = entities[i];
					
					if ( isEditorControllable( entity ) 
						&& entity.State !== undefined 
						&& entity.State.editorMode 
						&& entity.State.isSelected
						&& entity.State.isTranslating ) {
						collected.push( entity );
						collectId.push( entity._id);
					}
				}

				if ( !collected.length ) return;
			//	debugMode && console.log( syslogcid( system, collectId ) );

				while ( collected.length ){
					update( collected.shift() );
				}

				function update( entity ){

					var object;

					if ( entity.Object3D ) object = entity.Object3D;
					else if ( entity.Group ) object = entity.Group;
					else if ( entity.Mesh )  object = entity.Mesh;
					else if ( entity.Line )  object = entity.Line;
					else if ( entity.Sprite ) object = entity.Sprite;
					else if ( entity.SkinnedMesh )  object = entity.SkinnedMesh;
					else if ( entity.LineSegments ) object = entity.LineSegments;

					try {

						var dist = Math.max(dt, 0.05);

						if ( keyboard.pressed("E") ) object.translateOnAxis( axisY,  dist ); // up,
						if ( keyboard.pressed("Q") ) object.translateOnAxis( axisY, -dist ); // down,

						if ( entity.State.isRotating ) {

							if ( keyboard.pressed("left") )  object.translateOnAxis( axisX, -dist ); // left,
							if ( keyboard.pressed("right") ) object.translateOnAxis( axisX,  dist ); // right,
							if ( keyboard.pressed("up") )    object.translateOnAxis( axisZ, -dist ); // forward,
							if ( keyboard.pressed("down") )  object.translateOnAxis( axisZ,  dist ); // backward,

						} else {

						//	move up/down/left/right/forward/backward (local coordinates)
							if ( keyboard.pressed("A") || keyboard.pressed("left") )  object.translateOnAxis( axisX, -dist ); // left,
							if ( keyboard.pressed("D") || keyboard.pressed("right") ) object.translateOnAxis( axisX,  dist ); // right,
							if ( keyboard.pressed("W") || keyboard.pressed("up") )    object.translateOnAxis( axisZ, -dist ); // forward,
							if ( keyboard.pressed("S") || keyboard.pressed("down") )  object.translateOnAxis( axisZ,  dist ); // backward,

						//	move up/down/left/right/forward/backward (local coordinates)
						//	if ( keyboard.pressed("E") )                              object.translateY(  dist ); // up,
						//	if ( keyboard.pressed("Q") )                              object.translateY( -dist ); // down,
						//	if ( keyboard.pressed("A") || keyboard.pressed("left") )  object.translateX( -dist ); // left,
						//	if ( keyboard.pressed("D") || keyboard.pressed("right") ) object.translateX(  dist ); // right,
						//	if ( keyboard.pressed("W") || keyboard.pressed("up") )    object.translateZ( -dist ); // forward,
						//	if ( keyboard.pressed("S") || keyboard.pressed("down") )  object.translateZ(  dist ); // backward,

						//	move up/down/left/right/forward/backward (global coordinates)
						//	if ( keyboard.pressed("E") )                              object.position.y += dist; // up,
						//	if ( keyboard.pressed("Q") )                              object.position.y -= dist; // down,
						//	if ( keyboard.pressed("A") || keyboard.pressed("left") )  object.position.x -= dist; // left,
						//	if ( keyboard.pressed("D") || keyboard.pressed("right") ) object.position.x += dist; // right,
						//	if ( keyboard.pressed("W") || keyboard.pressed("up") )    object.position.z	-= dist; // forward,
						//	if ( keyboard.pressed("S") || keyboard.pressed("down") )  object.position.z	+= dist; // backward,

						}

					} catch(err){
						debugMode && console.error( "SystemError:", system, err );
					};

				}

			}
*/
		</script>

	</body>
</html>
